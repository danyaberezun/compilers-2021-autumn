-- Expression evaluator

import List;
import State;
import World;

-- As association map which maps "\otimes" into "\oplus"
var ops = {
  ["+" , infix + ],
  ["-" , infix - ],
  ["*" , infix * ],
  ["/" , infix / ],
  ["%" , infix % ],
  ["==", infix ==],
  ["!=", infix !=],
  ["<" , infix < ],
  ["<=", infix <=],
  [">" , infix > ],
  [">=", infix >=],
  ["&&", infix &&],
  ["!!", infix !!]
};

-- The evaluator for infix operators: takes an operator as a string
-- and two operand values, and returns the result
public fun evalOp (op, l, r) {
  case assoc (ops, op) of
    Some (f) -> f (l, r)
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn    (expr, expr)         |
--        Seq     (expr, expr)         |
--        Skip                         |
--        Read    (string)             |
--        Write   (expr)               |
--        If      (expr, expr, expr)   |
--        While   (expr, expr)         |
--        DoWhile (expr, expr)         |
--        Var     (string)             |
--        Ref     (string)             |
--        Const   (int)                |
--        Binop   (string, expr, expr) |
--        Ignore  (expr)

-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values
fun evalList(c, exprs) {
  case foldl (fun([c, vals], e) {
                case eval(c, e) of
                  [c, v] -> [c, v : vals]
                esac
              },
              [c, {}],
              exprs) of
    [c, vals] -> [c, reverse (vals)]
  esac
}

fun eval (c@[s, w], expr) {
  case expr of
    Var (varName) -> [c, s(varName)]       |
    Const (valName) -> [c, valName]        |
    Ref(refName) -> [c, RefVal(refName)]   |
    Binop (operation, lExpr, rExpr) ->
      case evalList(c, {lExpr, rExpr}) of
        [newC, {lRet, rRet}] -> [
          newC,
          evalOp(operation, lRet, rRet)
        ]
      esac                                 |
    Skip -> [c, Bot]                       |
    Assn (l, r) ->
      case evalList(c, {l, r}) of
        [[newS, newW], {RefVal(x), v}] ->
            [[newS <- [x, v], newW], v]
      esac                                 |
    Seq (l, r) ->
      case eval(c, l) of
        [newC, _] -> eval(newC, r)
      esac                                 |
    Read (x) ->
      case readWorld(w) of
        newW @ [i, o] ->
          [[s <- [x, i], o], Bot]
      esac                                 |
    Write (e) ->
      case eval(c, e) of
        [newC @ [newS, newW], x] -> [
          [newS, writeWorld(x, newW)],
          Void
        ]
      esac                                 |
    If (ifExpr, thenStmt, tailStmt) ->
      case eval (c, ifExpr) of
        [newC, 0] -> eval(newC, tailStmt) |
        [newC, _] -> eval(newC, thenStmt)
      esac                                 |
    While (whileExpr, whileStmt) ->
      case eval(c, whileExpr) of
        [newC, 0] -> [c, Void]           |
        [newC, _] -> eval(
          newC,
          Seq(
            whileStmt,
            While(whileExpr, whileStmt)
          )
        )
      esac                                 |
    DoWhile (doWhileStmt, doWhileExpr) ->
      eval(
        c,
        Seq(
          doWhileStmt,
          While(doWhileExpr, doWhileStmt)
        )
      )                                    |
    Ignor (e) -> [eval(c, e).fst, Bot]
  esac
}


-- Binary operation evaluator: takes operation, left value and
-- right value, returns result of the operation.

public fun evalBinOp(op, l, r) {
  case op of
    "+" ->  l + r                           |
    "-" ->  l - r                           |
    "*" ->  l * r                           |
    "/" ->  l / r                           |
    "%" ->  l % r                           |
    ">" ->  l > r                           |
    "<" ->  l < r                           |
    "<=" -> l <= r                          |
    ">=" -> l >= r                          |
    "==" -> l == r                          |
    "!=" -> l != r                          |
    "&&" -> l && r                          |
    "!!" -> l !! r                          |
    x -> failure ("Operation"
                  + op
                  + " is not implemented.")
  esac
}

-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  case eval ([emptyState, createWorld (input)], expr) of
    [c, _] -> c.snd.getOutput
  esac
}
