-- Lexical analysis using Matcher
import Matcher;
import Ostap;
import Fun;
import Collection;
import List;

-- A hashtable to keep a source code location information.
-- The keys in this table is a (boxed) value, and values are
-- pairs [line, column]
var srcTab = emptyHashTab (1024, hash, flatCompare);

-- A custom combinator to additionally add location info
public fun located (p) {
  loc |> fun (l) {p @ fun (x) {srcTab := addHashTab (srcTab, x, l); x}}
}

-- Retrieves location info; fail if no info found
public fun getLoc (s) {
  case findHashTab (srcTab, s) of Some (loc) -> loc esac
}

-- A set of all keywords
var keywords = foldl(
  addSet,
  emptySet(compare),
  {
    "read",
    "write",
    "skip",
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "while",
    "do",
    "od",
    "for"
  }
);

-- Regular expression definitions
public rWhiteSpace  = createRegexp("\\(\\([ \n\r\t]*\\)\\|\\(--[^\n]*[ \n\r\t]*\\)\\)*", "whitespace");
public rDecimal     = createRegexp("-?[0-9]+", "decimal constant");
public rLident      = createRegexp("[a-z][a-z_A-Z0-9]*", "lowercase identifier");
public rRead        = createRegexp("read\\b", """read""");
public rWrite       = createRegexp("write\\b", """write""");
public rSkip        = createRegexp("skip\\b", """skip""");
public rIf          = createRegexp("if\\b", """if""");
public rThen        = createRegexp("then\\b", """then""");
public rElse        = createRegexp("else\\b", """else""");
public rElif        = createRegexp("elif\\b", """elif""");
public rFi          = createRegexp("fi\\b", """fi""");
public rWhile       = createRegexp("while\\b", """while""");
public rDo          = createRegexp("do\\b", """do""");
public rOd          = createRegexp("od\\b", """od""");
public rFor         = createRegexp("for\\b", """for""");

var whiteSpace = token (rWhiteSpace);

-- Public parsers for concrete tokens
-- Generic token parser; t is either a string or a regular expression.
public fun s(t) { memo $ whiteSpace |> lift (token(t)) }

-- Some individual tokens
public kRead    = s(rRead);
public kWrite   = s(rWrite);
public kSkip    = s(rSkip);
public kIf      = s(rIf);
public kThen    = s(rThen);
public kElse    = s(rElse);
public kElif    = s(rElif);
public kFi      = s(rFi);
public kWhile   = s(rWhile);
public kDo      = s(rDo);
public kOd      = s(rOd);
public kFor     = s(rFor);
public decimal  = s(rDecimal);
public end      = memo $ whiteSpace |> lift (eof);
public lident   = memo $
  whiteSpace |> lift(fun(k) {
    fun(s) {
      k(
        case s.matchRegexp (rLident) of
            a@Succ(v, _) -> if memSet(keywords, v)
              then Fail("lowercase identifier expected", s.getLine, s.getCol)
              else a
              fi
          | a -> a
        esac
      )
    }
  });
