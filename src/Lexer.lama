-- Lexical analysis using Matcher

import Matcher;
import Ostap;
import Fun;
import Collection;
import List;

-- A set of all keywords
var keywords = foldl (addSet, emptySet (compare), {"read", "write", "skip"});
var binops7 = foldl (addSet, emptySet (compare), {"*", "/", "%"}),
    binops6 = foldl (addSet, emptySet (compare), {"+", "-"}),
    binops4 = foldl (addSet, emptySet (compare), {"<", ">", "<=", ">=", "==", "!="}),
    binops3 = foldl (addSet, emptySet (compare), {"&&", "!!"});

-- Regular expression definitions
var rWhiteSpace  = createRegexp ("\\(\\([ \n\r\t]*\\)\\|\\(--[^\n]*[ \n\r\t]*\\)\\)*", "whitespace"),
    rDecimal     = createRegexp ("-?[0-9]+", "decimal constant"),
    rLident      = createRegexp ("[a-z][a-z_A-Z0-9]*", "lowercase identifier"),
    rRead        = createRegexp ("read\\b", """read"""),
    rWrite       = createRegexp ("write\\b", """write"""),
    rSkip        = createRegexp ("skip\\b", """skip"""),
    rBinop       = createRegexp ("[+*/%<>=!&\-]+", "binary operator");

var whiteSpace = token (rWhiteSpace);

-- Public parsers for concrete tokens
-- Generic token parser; t is either a string or a regular expression
public fun s (t) {memo $ whiteSpace |> lift (token (t))}


public fun makeBinopsParser(binops) {
  memo $
    fun (k) {
      fun (is) {
        fun h (a) {
          case a of
            a@Succ(v, _) ->
              if memSet (binops, v) then
                k (a)
              else
                var msg = sprintf("unsupported binary operator '%s'", v);
                k (Fail (msg, is.getLine, is.getCol))
              fi
          | a -> k (a)
          esac
        }
        s (rBinop) (h) (is)
      }
    }
}

-- Some individual tokens
public kRead    = s (rRead),
       kWrite   = s (rWrite),
       kSkip    = s (rSkip),
       decimal  = s (rDecimal),
       end      = memo $ whiteSpace |> lift (eof),
       kBinop7  = makeBinopsParser(binops7),
       kBinop6  = makeBinopsParser(binops6),
       kBinop4  = makeBinopsParser(binops4),
       kBinop3  = makeBinopsParser(binops3),
       lident   = memo $       
         whiteSpace |> lift (fun (k) {
                                fun (s) {
                                  k (case s.matchRegexp (rLident) of
                                       a@Succ (v, _) -> if memSet (keywords, v) then Fail ("lowercase identifier expected", s.getLine, s.getCol) else a fi
                                     | a             -> a
                                     esac)
                                }
                              });

