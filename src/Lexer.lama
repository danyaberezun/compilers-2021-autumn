-- Lexical analysis using Matcher

import Matcher;
import Ostap;
import Fun;
import Collection;
import List;

-- A set of all keywords
var keywords = foldl (addSet, emptySet (compare), {"read", "write", "skip"});

-- Regular expression definitions
var rWhiteSpace  = createRegexp ("\\(\\([ \n\r\t]*\\)\\|\\(--[^\n]*[ \n\r\t]*\\)\\)*", "whitespace"),
    rDecimal     = createRegexp ("-?[0-9]+", "decimal constant"),
    rLident      = createRegexp ("[a-z][a-z_A-Z0-9]*", "lowercase identifier"),
    rRead        = createRegexp ("read\\b", """read"""),
    rWrite       = createRegexp ("write\\b", """write"""),
    rSkip        = createRegexp ("skip\\b", """skip""");

-- Parser, which parses whitespace and comments.
var whiteSpace = token (rWhiteSpace);

-- A parser combinator, which accept parser p and returns parser, which first skips any whitespace.
fun skipWhiteSpace (p) {
  whiteSpace |> lift (p)
}

-- Public parsers for concrete tokens
-- Generic token parser; t is either a string or a regular expression
public fun s (t) {
  memo $ skipWhiteSpace (token (t))
}

fun lident0 (k) {
  fun (s) {
    k (case matchRegexp (s, rLident) of
         a@Succ (v, _) -> if memSet (keywords, v) then Fail ("lowercase identifier expected", s.getLine, s.getCol) else a fi
       | a             -> a
       esac)
  }
}

-- Some individual tokens
public kRead    = s (rRead);
public kWrite   = s (rWrite);
public kSkip    = s (rSkip);
public decimal  = s (rDecimal);
public end      = memo $ skipWhiteSpace (eof);
public lident = memo $ skipWhiteSpace (lident0);
