-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun opStr (op) {
  syntax (s[op] {op})
}

var binop0 = syntax (opStr["!!"]);

var binop1 = syntax (opStr["&&"]);

var binop2 = syntax (
  opStr[">"] |
  opStr["<"] |
  opStr[">="] |
  opStr["<="] |
  opStr["=="] |
  opStr["!="]
);

var binop3 = syntax (
  opStr["+"] |
  opStr["-"]
);

var binop4 = syntax (
  opStr["*"] |
  opStr["/"] |
  opStr["%"]
);

fun opExpr (binop, lelem, relem) {
  syntax (l=lelem op=binop r=relem {Binop (op, l, r)})
}

var sum4 = memo $ eta syntax ( opExpr4 | primary );

var opExpr4 = memo $ eta syntax (
  opExpr[binop4, sum4, primary]
);

var sum3 = memo $ eta syntax ( opExpr3 | opExpr4 | primary );

var opExpr3 = memo $ eta syntax (
  opExpr[binop3, sum3, sum4]
);

var sum2 = memo $ eta syntax ( opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr2 = memo $ eta syntax (
  opExpr[binop2, sum2, sum3]
);

var sum1 = memo $ eta syntax ( opExpr1 | opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr1 = memo $ eta syntax (
  opExpr[binop1, sum1, sum2]
);

var sum0 = memo $ eta syntax ( opExpr0 | opExpr1 | opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr0 = memo $ eta syntax (
  opExpr[binop0, sum0, sum1]
);

-- Primary expression
(*var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (failure ("expression parsing not implemented\n"));*)

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
  exp = memo $ eta syntax (
    sum0
  );

var readPat  = memo $ eta syntax ( kRead x=inbr[s("("), lident, s(")")] {Read (x)} ),
    writePat = memo $ eta syntax ( kWrite x=inbr[s("("), exp, s(")")] {Write (x)} ),
    assnPat  = memo $ eta syntax ( l=lident s[":="] r=exp {Assn (l, r)} ),
    skipPat = memo $ eta syntax ( kSkip {Skip} ),
    whilePat = memo $ eta syntax ( kWhile x=exp kDo y=stmt kOd {While (x, y)} );

var stmtFirst = memo $ eta syntax (whilePat | assnPat | readPat | writePat | skipPat);

var stmt = memo $ eta syntax (
    l=stmtFirst s[";"] r=stmt {Seq (l, r)} | stmtFirst
);

-- Public top-level parser
public parse = stmt;

logOn ()