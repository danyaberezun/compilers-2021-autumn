-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error(msg, loc) {
  failure("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
      Ref  -> error("reference expected", loc)
    | Void -> Ignore(v)
    | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
      Void -> v
    | Val  -> error("value expected", loc)
    | _    -> error("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
      fun (a) {
        assertValue(a, Binop(op, l(Val), r(Val)), loc)
      }
    }
  ]
}
var elseOrSkip = memo $ eta syntax (
  -kElse exp | empty {
    fun (a) {
      case a of
        _ -> Skip
      esac
    }
  }
);
var ifBody = memo $ eta syntax (
  condition = basic -kThen body = exp next = elseBody {
    fun (a) {
      If (condition (Val), body (a), next (a))
    }
  }
);
var elseBody = memo $ eta syntax (
  -kElif ifBody | elseOrSkip
);
var primary = memo $ eta syntax (
  -- decimal constant
  loc = pos x = decimal {
    fun (a) {
      assertValue (a, Const (stringInt(x)), loc)
    }
  } |
  -- identifier
  x = lident {
    fun (a) {
      case a of
          Ref  -> Ref (x)
        | Void -> Ignore (Var (x))
        | _    -> Var (x)
      esac
    }
  }
  | inbr[s ("("), exp, s (")")]
  | loc = pos kSkip {
      fun (a) { assertVoid (a, Skip, loc) }
    }
  | loc = pos kRead name = inbr[s ("("), lident, s (")")] {
      fun (a) {
        assertVoid (a, Read (name), loc)
      }
    }
  | loc = pos kWrite exp = inbr[s ("("), exp, s (")")] {
      fun (a) { assertVoid (a, Write (exp (Val)), loc) }
    }
  | -kIf ifBody = ifBody -kFi {
      fun (a) {
        ifBody (a)
      }
    }
  | loc = pos -kWhile condition = basic -kDo body = exp -kOd {
      fun (a) {
        assertVoid (a, While (condition (Val), body (Void)), loc)
      }
    }
  | loc=pos -kDo body=exp -kWhile condition=basic -kOd {
      fun (a) {
        assertVoid (a, DoWhile (body (Void), condition (Val)), loc)
      }
    }
  | -kFor
      beforeAll = exp   -s[","]
      condition = basic -s[","]
      afterAll = exp
    -kDo
      body = exp
    -kOd {
      fun (a) {
        var whileRes = While (condition (Val), Seq (body (Void), afterAll (a)));
        Seq (beforeAll (Void), whileRes)
      }
  }
);

var basic = memo $ eta (
  expr(
    {
      [
        Right,
        {
          [
            syntax (pos -s [":="]),
            fun (l, loc, r) {
              fun (a) {
                assertValue (a, Assn (l (Ref), r (Val)), loc)
              }
            }
          ]
        }
      ],
      [Left, map(binop, { "!!" })],
      [Left, map(binop, { "&&" })],
      [Nona, map(binop, { "==", "!=", "<", ">", "<=", ">=" })],
      [Left, map(binop, { "+", "-" })],
      [Left, map(binop, { "*", "/", "%" })]
    },
    primary
  )
);

var exp = memo $ eta syntax (
  basic
  | s1 = basic s [";"] s2 = exp {
      fun (a) {
        Seq (s1 (Void), s2 (a))
      }
    }
);

-- Public top-level parser
public parse = syntax (s=exp { s(Void) });
