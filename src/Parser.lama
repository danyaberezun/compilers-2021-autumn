-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primaryExp = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                    x=lident  {Var (x)}               |
                                    inbr[s("("), exp, s(")")]         ),
    exp7       = memo $ eta syntax (primaryExp | x=exp7 op=kBinop7 y=primaryExp { Binop (op, x, y) }),
    exp6       = memo $ eta syntax (exp7 | x=exp6 op=kBinop6 y=exp7 { Binop (op, x, y) }),
    exp4       = memo $ eta syntax (exp6 | x=exp4 op=kBinop4 y=exp6 { Binop (op, x, y) }),
    exp3       = memo $ eta syntax (exp4 | x=exp3 op=kBinop3 y=exp4 { Binop (op, x, y) }),
    exp        = exp3;

var pread    = memo $ eta syntax (-kRead  x=inbr[s("("), lident, s(")")] { Read (x) }),
    pwrite   = memo $ eta syntax (-kWrite e=inbr[s("("), exp, s(")")] { Write (e) }),
    pskip    = memo $ eta syntax (-kSkip { Skip }),
    passn    = memo $ eta syntax (x=lident s[":="] e=exp { Assn (x, e) }),
    pelif    = memo $ eta syntax (-kElif e=exp -kThen t=stmt -kElse f=stmt -kFi { If (e, t, f) } |
                                  -kElif e=exp -kThen t=stmt f=pelif { If (e, t, f) }),
    pif      = memo $ eta syntax (-kIf e=exp -kThen t=stmt -kFi { If (e, t, Skip) } |
                                  -kIf e=exp -kThen t=stmt -kElse f=stmt -kFi { If (e, t, f) } |
                                  -kIf e=exp -kThen t=stmt f=pelif { If (e, t, f) }),
    pwhile   = memo $ eta syntax (-kWhile e=exp -kDo s=stmt -kOd { While (e, s) }),
    pdowhile = memo $ eta syntax (-kDo s=stmt -kWhile e=exp -kOd { DoWhile (s, e) }),
    pfor     = memo $ eta syntax (-kFor ini=stmt -s[","] e=exp -s[","] fini=stmt -kDo a=stmt -kOd
                                  { Seq (ini, While (e, Seq (a, fini))) }),

    primaryStmt = memo $ eta syntax (passn | pread | pwrite | pskip | pif | pwhile | pdowhile | pfor),
    stmt        = memo $ eta syntax (primaryStmt | x=primaryStmt s[";"] y=stmt { Seq (x, y) });
 

-- Public top-level parser
public parse = stmt;
