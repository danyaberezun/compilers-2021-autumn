-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    exp = (
		fun binop (l, op, r) { Binop (op, l, r) }
		memo $ eta expr ({
        [Left, { [s("!!"), binop] , [s("&&"), binop]}],
        [Nona, { [s("<"), binop], [s("<="), binop], [s(">="), binop], [s(">"), binop], [s("=="), binop], [s("!="), binop] }],
        [Left, { [s("+"), binop], [s("-"), binop] }],
        [Left, { [s("*"), binop], [s("/"), binop], [s("%"), binop] }]
      }, primary)
	);

var stmt = memo $ eta syntax (
    cur = single s[";"] rest = stmt { Seq(cur, rest) } |
    last = single { last }
  ),
    single = memo $ eta syntax (
      v = lident s[":="] e = exp { Assn(v, e) }          |
      kSkip { Skip }                                     |
      kRead v = inbr[s("("), lident, s(")")] { Read(v) } |
      kWrite e = inbr[s("("), exp, s(")")] { Write(e) }
    );


-- Public top-level parser
public parse = stmt;
