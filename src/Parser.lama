-- Parser 
import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
   syntax (-l p -r)
}
fun seqConstructor (rest, stmt) {
   Seq(stmt, rest)
}
fun binopParser (op) {
   [s(op), fun (l, op, r) {Binop(op, l, r)}]
}
-- Primary expression
var primary = memo $ eta syntax (
                       x=decimal {Const(stringInt(x))} |
                       
                       x=lident {Var(x)} |
                       
                       inbr[s("("), exp, s(")")]
                     ),
    exp     = memo $ expr({[Left, {"!!".binopParser}],
                   [Left, {"&&".binopParser}],
                   [Nona, map(binopParser, {"==", "!=", "<=", "<", ">=", ">"})],
                   [Left, map(binopParser, {"+", "-"})],
                   [Left, map(binopParser, {"*", "/", "%"})]}, primary);
var stmt = memo $ eta syntax (
                          kSkip {Skip} |
                          
                          name=lident s[":="] e=exp {Assn(name, e)} |
                          
                          kRead name=inbr[s("("), lident, s(")")] {Read(name)} |
                          
                          kWrite e=inbr[s("("), exp, s(")")] {Write(e)}
                        );
var program = list0By(stmt, s(";")) @ fun (l) {foldr(seqConstructor, Skip, l)};
public parse = program;