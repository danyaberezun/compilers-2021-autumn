-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (v, loc) {
  fun (atr) {
    case atr of
      Ref  -> error ("reference expected", loc)
    | Void -> Ignore (v)
    | _    -> v
    esac
  }
}

fun assertVoid (v, loc) {
  fun (atr) {
    case atr of
      Void -> v
    | Val  -> error ("value expected", loc)
    | _    -> error ("reference expected", loc)
    esac
  }
}

fun assertIf (condExpr, trueExpr, falseExpr) {
  fun (atr) {
    If (condExpr (Val), trueExpr (atr), falseExpr (atr))
  }
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parens (p) {
  inbr (s ("("), p, s (")"))
}

fun binop (op) {
  [
    syntax (pos -s[op]),
    fun (l, loc, r) {
      assertValue (Binop (op, l (Val), r (Val)), loc)
    }
  ]
}

var primary = memo $ eta syntax (
    loc=pos x=decimal {assertValue (Const (stringInt (x)), loc)}
  | x=lident {fun (a) {
      case a of
        Ref  -> Ref (x)
      | Void -> Ignore (Var (x))
      | _    -> Var (x)
      esac
    }}
  | x=parens[exp] {x}
  | loc=pos kRead x=parens[lident] {assertVoid (Read (x), loc)}
  | loc=pos kWrite x=parens[exp] {assertVoid (Write (x (Val)), loc)}
  | loc=pos kSkip {assertVoid (Skip, loc)}
  | kIf cond=exp kThen trueExpr=exp falseExpr=elseTail {assertIf (cond, trueExpr, falseExpr)}
  | loc=pos kWhile cond=exp kDo body=exp kOd {assertVoid (While (cond (Val), body (Void)), loc)}
  | loc=pos kDo body=exp kWhile cond=exp kOd {assertVoid (DoWhile (body (Void), cond (Val)), loc)}
  | loc=pos kFor init=exp s[","] cond=exp s[","] next=exp kDo body=exp kOd {
      assertVoid (Seq (init (Void), While (cond (Val), Seq (body (Void), next (Void)))), loc)
    }
);

var basic = memo $ eta expr ({
  [Right, {[s (":="), fun (l, loc, r) {assertValue (Assn (l (Ref), r (Val)), loc)}]}],
  [Left, map (binop, {"!!"})],
  [Left, map (binop, {"&&"})],
  [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
  [Left, map (binop, {"+", "-"})],
  [Left, map (binop, {"*", "/", "%"})]
}, primary);

var elseTail = memo $ eta syntax (
    loc=pos kFi {assertVoid (Skip, loc)}
  | kElse falseExpr=exp kFi {falseExpr}
  | kElif cond=exp kThen trueExpr=exp falseExpr=elseTail {assertIf (cond, trueExpr, falseExpr)}
);

var exp = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
