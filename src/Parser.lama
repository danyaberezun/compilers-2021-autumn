-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parens(p) {
  inbr (s ("("), p, s (")"))
}

fun binop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta (
    decimal @ fun (x) {Const (stringInt (x))}
  | lident  @ fun (x) {Var (x)}
  | parens (exp)
);

var exp = memo $ eta expr ({
  [Left, {
    [s ("!!"), binop]
  }],
  [Left, {
    [s ("&&"), binop]
  }],
  [Nona, {
    [s ("<"), binop],
    [s ("<="), binop],
    [s (">"), binop],
    [s (">="), binop],
    [s ("=="), binop],
    [s ("!="), binop]
  }],
  [Left, {
    [s ("+"), binop],
    [s ("-"), binop]
  }],
  [Left, {
    [s ("*"), binop],
    [s ("/"), binop],
    [s ("%"), binop]
  }]
}, primary);

var elseTail = memo $ eta syntax (
    kFi {Skip}
  | kElse falseStmt=stmt
    kFi {falseStmt}
  | kElif cond=exp
    kThen trueStmt=stmt
    falseStmt=elseTail
    {If (cond, trueStmt, falseStmt)}
);

var nonCompoundStmt = memo $ eta syntax (
    kRead
    x=parens[lident]
    {Read (x)}
  | kWrite
    x=parens[exp]
    {Write (x)}
  | kSkip {Skip}
  | to=lident
    s[":="]
    from=exp
    {Assn (to, from)}
  | kIf cond=exp
    kThen trueStmt=stmt
    falseStmt=elseTail
    {If (cond, trueStmt, falseStmt)}
  | kWhile cond=exp
    kDo body=stmt
    kOd
    {While (cond, body)}
  | kDo body=stmt
    kWhile cond=exp
    kOd
    {DoWhile (body, cond)}
  | kFor
    init=stmt s[","]
    cond=exp s[","]
    next=stmt kDo
    body=stmt
    kOd
    {Seq (init, While (cond, Seq (body, next)))}
);

var stmt = memo $ eta syntax (
    nonCompoundStmt
  | head=nonCompoundStmt
    s[";"]
    tail=stmt
    {Seq (head, tail)}
);
   

-- Public top-level parser
public parse = stmt;
