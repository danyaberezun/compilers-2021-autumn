-- Parser 

import Ostap;
import Matcher;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


fun makeBinop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      
  exp = memo $ eta expr ({[Left, {[s("!!"), makeBinop]}], 
                          [Left, {[s("&&"), makeBinop]}], 
                          [Nona, {[s("==") | s("!=") | s(">=") | s("<=") | s("<") | s(">"), makeBinop]}], 
                          [Left, {[s("+")  | s("-"), makeBinop]}], 
                          [Left, {[s("*")  | s("/") | s("%"), makeBinop]}]}, primary);

var simple_statement = memo $ eta syntax (kSkip                                {Skip}                                  |
                                         kRead x=inbr[s("("), lident, s(")")]  {Read(x)}                               |  
                                         kWrite e=inbr[s("("), exp, s(")")]    {Write(e)}                              |
                                         x=lident $(s(":=")) e=exp             {Assn(x, e)}                            |
                                         kWhile e=exp kDo body=stmt kOd        {While(e, body)}                        |
                                         kDo body=stmt kWhile e=exp kOd        {DoWhile(body, e)}                      |
                                         kIf e=exp kThen branchT=stmt branchF=elseBranch kFi {If(e, branchT, branchF)} |
                                         kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo body=stmt kOd {Seq(s1, While(e, Seq(body, s2)))}), 

  elseBranch = memo $ eta syntax (empty {Skip}     |
                                  kElse s=stmt {s} | 
                                  kElif e=exp kThen branchT=stmt branchF=elseBranch {If(e, branchT, branchF)}),

  stmt = memo $ eta syntax (simple_statement | left=simple_statement s[";"] remaining=stmt {Seq(left, remaining)});
   
-- Public top-level parser
public parse = stmt;