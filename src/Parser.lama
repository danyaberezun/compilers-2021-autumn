-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    exp      = memo $ eta syntax (expOR),
    expOR    = memo $ eta syntax (l=expOR     op=(s["!!"])                       r=expAND { Binop(op, l, r) }   | expAND),
    expAND   = memo $ eta syntax (l=expAND    op=(s["&&"])                       r=expCMP0 { Binop(op, l, r) }  | expCMP0),
    expCMP0  = memo $ eta syntax (l=expCMP0   op=(s[">"]|s[">="]|s["<"]|s["<="]) r=expCMP1 { Binop(op, l, r) }  | expCMP1),                    
    expCMP1  = memo $ eta syntax (l=expCMP1   op=(s["=="]|s["!="])               r=expMATH0 { Binop(op, l, r) } | expMATH0),
    expMATH0 = memo $ eta syntax (l=expMATH0  op=(s["+"]|s["-"])                 r=expMATH1 { Binop(op, l, r) } | expMATH1),
    expMATH1 = memo $ eta syntax (l=expMATH1  op=(s["*"]|s["/"]|s["%"])          r=primary { Binop(op, l, r) }  | primary);
      
var stmt = memo $ eta syntax (l=cmd op=(s[";"]) r=stmt { Seq(l, r) } | cmd),
    cmd  = memo $ eta syntax (cmdAssgn | cmdRead | cmdWrite | cmdSkip),
    cmdAssgn = memo $ eta syntax (x=lident op=(s[":="]) e=exp { Assn(x, e) }),
    cmdRead  = memo $ eta syntax (kRead x=inbr[s("("), lident, s(")")] { Read(x) }),
    cmdWrite = memo $ eta syntax (kWrite e=inbr[s("("), exp, s(")")] { Write(e) }),
    cmdSkip  = memo $ eta syntax (kSkip { Skip });
   

-- Public top-level parser
public parse = stmt;