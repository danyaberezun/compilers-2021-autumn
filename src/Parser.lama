-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun buildBinop (op) {
  fun (l, o, r) {
    Binop (op, l, r)
  }
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const (stringInt (x)) } |
                                 x=lident  { Var (x) }               |
                                 inbr[s("("), exp, s(")")]),
    exp = memo $ eta expr (
      {
        [Left, {[s("!!"), buildBinop ("!!")]}],
        [Left, {[s("&&"), buildBinop ("&&")]}],
        [Left,
          {[s("=="), buildBinop ("==")],
            [s("!="), buildBinop ("!=")],
            [s("<" ), buildBinop ("<" )],
            [s("<="), buildBinop ("<=")],
            [s(">" ), buildBinop (">" )],
            [s(">="), buildBinop (">=")]
          }],
        [Left,
          {[s("+"), buildBinop ("+")],
            [s("-"), buildBinop ("-")]
          }],
        [Left,
          {[s("*"), buildBinop ("*")],
            [s("/"), buildBinop ("/")],
            [s("%"), buildBinop ("%")]
          }]
      },
      primary
    );

var stmt = memo $ eta syntax (
  (kRead e=inbr[s("("), lident, s(")")]                      { Read  (e)                         }) |
  (kWrite e=inbr[s("("), exp, s(")")]                        { Write (e)                         }) |
  (kSkip                                                     { Skip                              }) |
  (v=lident s[":="] e=exp                                    { Assn (v, e)                       }) |
  (kDo s=stmts kWhile e=exp kOd                              { DoWhile (s, e)                    }) |
  (kWhile e=exp kDo s=stmts kOd                              { While (e, s)                      }) |
  (kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmts kOd { Seq (s1, While (e, Seq (s3, s2))) }) |
  (kIf e=exp kThen s=stmts kFi                               { If (e, s, Skip)                   }) |
  (kIf e=exp kThen s1=stmts alts=elifs kFi                   { If (e, s1, alts)                  })
  );

var elifs = memo $ eta syntax (
  (kElif e=exp kThen s=stmts alts=elifs { If (e, s, alts) }) |
  (kElif e=exp kThen s=stmts            { If (e, s, Skip) }) |
  (kElse s=stmts                        { s })
  );

var stmts = syntax (
  s=stmt                      { s            } |
  s1=stmt token[";"] s2=stmts { Seq (s1, s2) }
  );

-- Public top-level parser
public parse = stmts;
