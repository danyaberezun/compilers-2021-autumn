-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun describe(symb) {
  [s(symb), fun (l, op, r) {Binop(symb, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta ( expr (
        {
          [Left, {describe ("!!")}],
          [Left, {describe ("&&")}],
          [Nona, map (describe, {"==", "!=", "<", "<=", ">", ">="})],
          [Left, map (describe, {"+", "-"})],
          [Left, map (describe, {"*", "/", "%"})]
        }
        , primary));

var stmt = memo $ eta syntax(single_stmt | l=single_stmt s[";"] r=stmt {Seq (l, r)}),
  single_stmt = memo $ eta syntax (
    s=if_stmt {s} | 
    kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
    kWrite e=inbr[s("("), exp, s(")")] {Write (e)} |
    kSkip {Skip} | 
    x=lident s[":="] e=exp {Assn(x, e)} |
    s=while_stmt {s} 
  ),
  if_stmt = memo $ eta syntax (
    kIf e=exp kThen s=stmt post=if_postfix {If(e, s, post)}
  ),
  if_postfix = memo $ eta syntax (
    kFi {Skip} | 
    kElse s=stmt kFi {s} |
    kElif e=exp kThen s=stmt post=if_postfix {If(e, s, post)} 
  ),
  while_stmt = memo $ eta syntax (
    kWhile e=exp kDo s=stmt kOd {While(e, s)} |
    kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd {Seq(s1, While(e, Seq(s3, s2)))} |
    kDo s=stmt kWhile e=exp kOd {DoWhile(s, e)} 
  )
;
   

-- Public top-level parser
public parse = stmt;
