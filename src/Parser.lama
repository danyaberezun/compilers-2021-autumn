-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
         {
          [Left, {[s("&&") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("!!"), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Nona, {[s("==") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("!="), fun (l, op, r) {Binop (op, l, r)}],
                [s(">"), fun (l, op, r) {Binop (op, l, r)}],
                [s("<"), fun (l, op, r) {Binop (op, l, r)}],
                [s(">="), fun (l, op, r) {Binop (op, l, r)}],
                [s("<="), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Left, {[s("+"), fun (l, op, r) {Binop (op, l, r)}] ,
                [s("-"), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Left, {[s("*") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("/"), fun (l, op, r) {Binop (op, l, r)}],
                [s("%"), fun (l, op, r) {Binop (op, l, r)}]
                }]
         }, primary);

var stmt = memo $ eta syntax (
  v=lident s[":="] e=exp { Assn(v, e) } |
  kSkip { Skip } |
  kRead v=inbr[s("("), lident, s(")")] { Read(v) } |
  kWrite v=exp { Write(v) }
);
   
var stmtList = eta syntax (
  l=stmt { l } |
  r=stmt s[";"] t=stmtList {Seq(r, t)}
);

-- Public top-level parser
public parse = stmtList;
             
