-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun infixExp(op) {
  [s (op), fun (l, t_op, r) {Binop (t_op, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr ({
                            [
                              Left,
                              {
                                infixExp("!!"),
                                infixExp("&&")
                              }
                            ],
                            [
                              Nona,
                              {
                                infixExp("=="),
                                infixExp("<="),
                                infixExp("<"),
                                infixExp(">="),
                                infixExp(">"),
                                infixExp("!=")
                              }
                            ],
                            [
                              Left,
                              {
                                infixExp("+"),
                                infixExp("-")
                              }
                            ],
                            [
                              Left,
                              {
                                infixExp("*"),
                                infixExp("/"),
                                infixExp("%")
                              }
                            ]
                          }, primary));

var ifBody = memo $ eta syntax (
  cond=exp kThen s=stmts                            { If(cond, s, Skip) } |  -- if then 
  cond=exp kThen branch1=stmts kElif branch2=ifBody { If(cond, branch1, branch2) } | -- if then elif...
  cond=exp kThen branch1=stmts kElse branch2=stmts  { If(cond, branch1, branch2) }  -- if then else
);

var stmt = memo $ eta syntax (
  variable=lident s[":="] value=exp { Assn(variable, value) } |
  kRead s["("] variable=lident s[")"] { Read(variable)} |
  kWrite s["("] value=exp s[")"] { Write(value) } |
  kSkip { Skip } |
  kWhile cond=exp kDo ss=stmts kOd {While (cond, ss)} |
  kIf body=ifBody kFi { body } |
  kFor s1=stmt s[","] cond=exp s[","] s2=stmt kDo body=stmts kOd {Seq (s1, While (cond, Seq (body, s2)))} |
  kDo ss=stmts kWhile cond=exp kOd { DoWhile (ss, cond) }
);

var stmts = memo $ eta syntax (
    s=stmt token[";"] ss=stmts {Seq(s, ss)} |
    stmt
);

-- Public top-level parser
public parse = stmts;