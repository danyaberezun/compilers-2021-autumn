-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop(l, op, r) {
  Binop(op, l, r)
}

var operations = {
  [Left, "&&":{}],
  [Left, "!!":{}],
  [Nona, {"==", "<=", "<", ">=", ">", "!="}], -- left assoc is not needed
  [Left, {"+", "-"}],
  [Left, {"*", "/", "%"}]
};

fun mapper([assosiation, opData]) {
    [assosiation, map(fun (currOp) {
       [s(currOp), binop]
    }, opData)]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (map(mapper, operations), primary);

var atomicStmt = memo $ eta syntax (kRead x=inbr[ s("("), lident, s(")") ] { Read(x) } |
                                     kWrite x=inbr[ s("("), exp, s(")") ]  { Write(x) } |
                                     x=lident s[":="] e=exp { Assn (x, e) } |
                                     kSkip { Skip } ),
        stmts = memo $ eta syntax (l=atomicStmt s[";"] r=stmts { Seq(l, r) } |
                                    atomicStmt);

-- Public top-level parser
public parse = stmts;
