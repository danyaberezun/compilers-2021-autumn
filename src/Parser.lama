-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun tokenToBinop (l, op, r) {
  Binop (op, l, r)
}

fun tokensFromNames (names) {
  map (fun (name) {[s (name), tokenToBinop]}, names)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    exp = memo $ eta (expr ({ [Left, tokensFromNames({ "!!" })],
                              [Left, tokensFromNames({ "&&" })],
                              [Nona, tokensFromNames({ "==", "!=", "<=", "<", ">=", ">" })],
                              [Left, tokensFromNames({ "+", "-" })],
                              [Left, tokensFromNames({ "*", "/", "%" })] 
                            }, primary
                            ));


var simpleStmt = memo $ eta syntax (kRead x=inbr[s ("("), lident, s (")")] { Read (x) }      |
                                    kWrite x=inbr[s ("("), exp, s (")")] { Write (x) }       |
                                    kSkip { Skip }                                           |
                                    x=lident s[":="] v=exp { Assn (x, v) }                   |
                                    ifP                                                      |
                                    kFor i=stmt s[","] c=exp s[","] u=stmt kDo b=stmt kOd {
                                      Seq (i, While (c, Seq (b, u)))
                                    }                                                        |
                                    kWhile c=exp kDo b=stmt kOd { While (c, b) }             |
                                    kDo b=stmt kWhile c=exp kOd { DoWhile (b, c) }),
    ifP = memo $ eta syntax (kIf c=exp kThen t=stmt e=elsePart { If (c, t, e) }),
    elsePart = memo $ eta syntax (-kElse stmt -kFi                                         |
                                  kElif c=exp kThen t=stmt e=elsePart { If (c, t, e) } |
                                  kFi { Skip }),
    stmt = memo $ eta (expr ({ [Left, { [s (";"), fun (l, op, r) { Seq (l, r) }] }] }, simpleStmt));
   

-- Public top-level parser
public parse = stmt;
