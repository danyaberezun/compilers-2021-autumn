-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun procBinops (binops) {
  fun makeBinop (l, op, r) {
    Binop (op, l, r)
  }

  fun procBinop (op) {
    [s (op), makeBinop]
  }

  fun procBinopGroup ([assoc, ops]) {
    [assoc, map (procBinop, ops)]
  }

  map (procBinopGroup, binops)
}

var binops = procBinops ({
  [Right, {"!!"}],
  [Right, {"&&"}],
  [Nona,  {"==", "!=", "<", "<=", ">", ">="}],
  [Left,  {"+", "-"}],
  [Left,  {"*", "/", "%"}]
});

var lParens = memo $ eta (s ("("));
var rParens = memo $ eta (s (")"));
fun parens (p) {
  inbr (lParens, p, rParens)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal { Const (stringInt (x)) } 
| x=lident  { Var (x) }               
| parens[exp]
),
    exp = memo $ eta (expr (binops, primary));

var assign = memo $ eta (s (":="));
var stmtEnd = memo $ eta (s (";"));

var stmt = memo $ eta syntax (
  kRead v=parens[lident] { Read (v) }
| kWrite v=parens[exp] { Write (v) }
| kSkip { Skip }
| v=lident assign nv=exp { Assn (v, nv) }
| f=stmt stmtEnd s=stmt end { Seq (f, s) }
);

-- Public top-level parser
public parse = stmt;
             
