-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var disj = s ("!!");
var conj = s ("&&");
var comp = s ("==") | s ("!=") | s ("<=") | s ("<") | s (">=") | s (">");
var ops1 = s ("+") | s ("-");
var ops2 = s ("*") | s ("/") | s ("%");

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        {[Left, {[disj, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[conj, fun (l, op, r) {Binop (op, l, r)}]}],
         [Nona, {[comp, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[ops1, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[ops2, fun (l, op, r) {Binop (op, l, r)}]}]}, primary);



var elsePart = memo $ eta syntax (kElif x=exp kThen s=stmts es=elsePart {If (x, s, es)} |
                                  kElse s=stmts kFi {s} |
                                  kFi {Skip});

var stmt = memo $ eta syntax (kSkip {Skip} |
                              kRead i=inbr[s("("), lident, s(")")] {Read (i)} |
                              kWrite x=inbr[s("("), exp, s(")")] {Write (x)} |
                              kIf x=exp kThen s=stmts es=elsePart {If (x, s, es)} |
                              kWhile x=exp kDo s=stmts kOd {While (x, s)} |
                              kDo s=stmts kWhile x=exp kOd {DoWhile (s, x)} |
                              kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmts kOd {Seq (s1, While (e, Seq (s3, s2)))} |
                              i=lident s[":="] x=exp {Assn (i, x)});

var stmts = memo $ eta expr ({[Left, {[s (";"), fun (l, op, r) {Seq (l, r)}]}]}, stmt);
   

-- Public top-level parser
public parse = stmts;
             
