-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parseBinop(op) {
  [s(op), fun(l, op, r) {Binop(op, l, r)} ]
}

-- public fun evalBinop (op, l, r) {
--    case op of
--      "&&" -> l && r
--    | "!!" -> l !! r
--    | "==" -> l == r
--    | "!=" -> l != r
--    | ">"  -> l > r
--    | "<"  -> l < r
--    | ">=" -> l >= r
--    | "<=" -> l <= r
--    | "+"  -> l + r
--    | "-"  -> l - r
--    | "*"  -> l * r
--    | "/"  -> l / r
--    | "%"  -> l % r
--    | op   -> failure("undefined binary operation ""%s""\n", op)
--    esac
-- }

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (
        expr ({
          [Left, {
          parseBinop("!!"),
          parseBinop("&&")
          }],
          [Nona, {
            parseBinop("<"),
            parseBinop(">"),
            parseBinop("<="),
            parseBinop(">="),
            parseBinop("=="),
            parseBinop("!=")
          }],
          [Left, {
            parseBinop("+"),
            parseBinop("-")
          }],
          [Left, {
            parseBinop("*"),
            parseBinop("/"),
            parseBinop("%")

          }]
        }, primary));


var oneStmt = memo $ eta syntax (x=lident s[":="] e=exp                { Assn(x, e) } |
                                 kWrite e=inbr[s("("), exp, s(")")]    { Write(e) }   |
                                 kRead  x=inbr[s("("), lident, s(")")] { Read(x) }    |
                                 kSkip                                 { Skip } );
var stmt = memo $ eta syntax (oneStmt | s1=oneStmt s[";"] s2=stmt { Seq(s1, s2) } );   

-- Public top-level parser
public parse = stmt;
             
