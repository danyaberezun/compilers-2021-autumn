-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parseBinop(op) {
  [s(op), fun(l, op, r) {Binop(op, l, r)} ]
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (
        expr ({
          [Left, {
          parseBinop("!!"),
          parseBinop("&&")
          }],
          [Nona, {
            parseBinop("<"),
            parseBinop(">"),
            parseBinop("<="),
            parseBinop(">="),
            parseBinop("=="),
            parseBinop("!=")
          }],
          [Left, {
            parseBinop("+"),
            parseBinop("-")
          }],
          [Left, {
            parseBinop("*"),
            parseBinop("/"),
            parseBinop("%")

          }]
        }, primary));


var elseStmt = memo $ eta syntax (
  kElse s2=stmt {s2} |
  kElif e=exp kThen s=stmt el=elseStmt {If(e, s, el)}
);

var oneStmt = memo $ eta syntax (x=lident s[":="] e=exp                       { Assn(x, e) }       |
                                 kWrite e=inbr[s("("), exp, s(")")]           { Write(e) }         |
                                 kRead  x=inbr[s("("), lident, s(")")]        { Read(x) }          |
                                 kSkip                                        { Skip }             |
                                 kIf    e=exp kThen st=stmt kFi               { If(e, st, Skip)}   |
                                 kIf    e=exp kThen st=stmt  els=elseStmt kFi  { If(e, st, els )}   |
                                 kWhile e=exp kDo st=stmt kOd                 {While(e, st)}       |
                                 kDo    st=stmt kWhile e=exp kOd              {DoWhile(st, e)}     |
                                 kFor st1=stmt s[","] e=exp s[","] st2=stmt kDo st3=stmt kOd {Seq(st1, While(e, Seq(st3, st2)))}

);
var stmt = memo $ eta syntax (oneStmt | s1=oneStmt s[";"] s2=stmt { Seq(s1, s2) } );     

-- Public top-level parser
public parse = stmt;
