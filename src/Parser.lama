-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (
    x = decimal {Const (stringInt (x))} 
  | x = lident  {Var (x)}               
  | inbr[s("("), exp, s(")")]),

  -- fun expr(ops, opnd), 44 page in lama-spec
  exp = memo $ eta (expr(
    {[Left,  {[s("!!"), fun (l, op, r) {Binop("!!", l, r)}],
              [s("&&"), fun (l, op, r) {Binop("&&", l, r)}]}],

    [Nona,   {[s("=="), fun (l, op, r) {Binop("==", l, r)}],
              [s("!="), fun (l, op, r) {Binop("!=", l, r)}],
              [s(">"), fun (l, op, r) {Binop(">", l, r)}],
              [s("<"), fun (l, op, r) {Binop("<", l, r)}],
              [s(">="), fun (l, op, r) {Binop(">=", l, r)}],
              [s("<="), fun (l, op, r) {Binop("<=", l, r)}]}],

    [Left,   {[s("+"), fun (l, op, r) {Binop("+", l, r)}],
              [s("-"), fun (l, op, r) {Binop("-", l, r)}]}],

    [Left,   {[s("*"), fun (l, op, r) {Binop("*", l, r)}],
              [s("/"), fun (l, op, r) {Binop("/", l, r)}],
              [s("%"), fun (l, op, r) {Binop("%", l, r)}]}]
    }, primary)
  );
    -- exp = memo $ eta (failure ("expression parsing not implemented\n"));

-- Statements
var singlestmt = memo $ eta syntax (
    kRead  x = inbr[s("("), lident, s(")")] {Read(x)}
  | kWrite e = inbr[s("("), exp, s(")")] {Write(e)}
  | kSkip {Skip}
  | x = lident s[":="] e = exp {Assn(x, e)}
);

-- Sequence of Statements
var stmt = memo $ eta syntax (
    singlestmt
  | s1 = singlestmt s[";"] s2 = stmt {Seq(s1, s2)}
);
-- var stmt = memo $ eta (failure ("statement parsing not implemented\n"));
   

-- Public top-level parser
public parse = stmt;


-- Add following rules in parser:

-- if e then s1 else s2 
-- if true    -- count e in c --> get n != 0 --> get new configuration c' with s1
-- else false -- count e in c --> get n == 0 --> get new configuration c' with s2

-- while e do s
-- on every step of while count [[e]] in c --> get n != 0 --> get new configuration c' with s
-- on every step of while count [[e]] in c --> get n == 0 --> SKIP

-- Label l
-- P |- c -->(p1) c

-- JMP l
-- P |- c -->(p1(l)) c' -- take label on p1


-- Compilation rule for while e do s
-- 1. Label 1
-- 2. compile [[e]]
-- 3. CJMP_{z} End
-- 4. compile [[s]]
-- 5. JMP 1
-- 6. Label End

-- JMP is bad -- we need less jumps
-- 1. JMP 2
-- 2. Label 1
-- 3. compile [[s]] 
-- 4. Label 2
-- 5. compile [[e]]
-- 6. CJMP_{nz} 1 