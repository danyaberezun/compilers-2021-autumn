-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopRun (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr(
        {
          [Left, {[s ("!!"), binopRun]}],
          [Left, {[s ("&&"), binopRun]}],
          [Nona, {
            [s ("<"), binopRun],
            [s ("<="), binopRun],
            [s (">"), binopRun],
            [s (">="), binopRun],
            [s ("=="), binopRun],
            [s ("!="), binopRun]
          }],
          [Left, {[s ("+"), binopRun], [s ("-"), binopRun]}],
          [Left, {
            [s ("*"), binopRun],
            [s ("/"), binopRun],
            [s ("%"), binopRun]
          }]
        },
        primary
      );

fun addBrackets(p) {
  inbr (s ("("), p, s (")"))
}

var baseStmt = memo $ eta syntax
  (
    kSkip { Skip }
  | kRead x = addBrackets [lident] { Read(x) }
  | kWrite x = addBrackets [exp] { Write(x) }
  | to = lident s[":="] x = exp { Assn (to, x) }
  ),
  stmt = memo $ eta syntax (
    l = baseStmt s[";"]
    r = stmt { Seq(l, r) } | baseStmt
  );

-- Public top-level parser
public parse = stmt;