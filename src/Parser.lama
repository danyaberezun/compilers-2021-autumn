-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun defineBinops (assoc, ops) {
  [
    assoc,
    map (fun (op) { [s (op), fun (l, op, r) {Binop (op, l, r)} ] }, ops)
  ]
}

fun binop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
          {
            defineBinops(Left, {"!!"}),
            defineBinops(Left, {"&&"}),
            defineBinops(Nona, {"==", "!=", "<", "<=", ">", ">="}),
            defineBinops(Left, {"+", "-"}),
            defineBinops(Left, {"*", "/", "%"})
          }, primary),
      stmt = memo $ eta syntax (kSkip         { Skip }        |
        x=lident s[":="] e=exp                { Assn (x, e) } |
        kRead x=inbr[s("("), lident, s(")")]  { Read (x) }    |
        kWrite e=inbr[s("("), exp, s(")")]    { Write (e) }),
      stmtList = memo $ eta syntax (
        stmt |
        h=stmt s[";"] t=stmtList { Seq (h, t) }
      );

-- Public top-level parser
public parse = stmtList;

