-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),

    exp    = memo $ eta syntax (lhv=exp s["!!"] rhv=expAND { Binop ("!!", lhv, rhv) } | expAND),
    expAND = memo $ eta syntax (lhv=expAND s["&&"] rhv=expEQ { Binop ("&&", lhv, rhv) } | expEQ),
    expEQ  = memo $ eta syntax (lhv=expSUM op=(s["=="]|s["!="]|s["<="]|s[">="]|s["<"]|s[">"]) rhv=expSUM { Binop (op, lhv, rhv) } | expSUM),
    expSUM = memo $ eta syntax (lhv=expSUM op=(s["+"]|s["-"]) rhv=expMUL { Binop (op, lhv, rhv) } | expMUL),
    expMUL = memo $ eta syntax (lhv=expMUL op=(s["*"]|s["/"]|s["%"]) rhv=primary { Binop (op, lhv, rhv) } | primary);


      
var stmt = memo $ eta syntax   (single |
                                s1=single s[";"] s2=stmt {Seq(s1,s2)}),
    single = memo $ eta syntax (x=lident $(s(":=")) e=exp {Assn(x, e)} |
                                kRead v=inbr[s("("), lident, s(")")] {Read(v)} |
                                kWrite e=inbr[s("("), exp, s(")")] {Write(e)} |
                                kSkip {Skip} |
                                kWhile e=exp kDo body=stmt kOd {While(e, body)} |
                                kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd {Seq(s1, While(e, Seq(s3, s2)))} |
                                kDo body=stmt kWhile e=exp kOd {DoWhile(body, e)} |
                                kIf e=exp kThen tru=stmt kElse fls=stmt kFi {If(e, tru, fls)} |
                                kIf e=exp kThen tru=stmt fls=elifB {If(e, tru, fls)}
                                ),
    elifB = memo $ eta syntax (kFi {Skip} |
                                kElif e=exp kThen tru=stmt kElse fls=stmt kFi {If(e, tru, fls)} |
                                kElif e=exp kThen tru=stmt fls=elifB {If(e, tru, fls)}
                                );
   

-- Public top-level parser
public parse = stmt;
