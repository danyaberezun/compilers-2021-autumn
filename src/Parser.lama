-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inParentheses(p) {
  inbr (s ("("), p, s (")"))
}

fun foldl1 (f, l) {
  case l of
    head:tail -> foldl(f, head, tail)
  | _         -> failure ("List is empty")
  esac
}

fun binopLayout(assoc, ops) {
  fun makeRule (ops) {
    foldl1 (alt, map (fun (op) { s (op) }, ops))
  }
  fun toBinop (left, op, right) {
    Binop (op, left, right)
  }
  [assoc, {[makeRule (ops), toBinop]}]
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (expr ({
        binopLayout (Left, {"!!"}),
        binopLayout (Left, {"&&"}),
        binopLayout (Nona, {"==", "<", ">", "!=", ">=", "<="}),
        binopLayout (Left, {"+", "-"}),
        binopLayout (Left, {"*", "/", "%"})
      }, primary));

var semicolon = memo $ eta (s (";")),
    equals = memo $ eta (s (":=")),
    comma = memo $ eta (s (",")),
    elseBranch = memo $ eta syntax (
      kElse st=stmt kFi { st } |
      kElif expr=exp kThen first=stmt second=elseBranch { If (expr, first, second) } |
      kFi { Skip }
    );

var singleStmt = memo $ eta syntax (
      kRead name=inParentheses[lident] { Read (name) } |
      kWrite value=inParentheses[exp] { Write (value) } |
      name=lident equals value=exp { Assn (name, value) } |
      kSkip { Skip } |
      kIf expr=exp kThen first=stmt second=elseBranch { If (expr, first, second) } |
      kWhile expr=exp kDo st=stmt kOd { While (expr, st) } |
      kDo st=stmt kWhile expr=exp kOd { DoWhile (st, expr) } |
      kFor s1=stmt comma expr=exp comma s2=stmt kDo s3=stmt kOd { Seq (s1, While (expr, Seq (s3, s2))) }
    ),
    stmt = memo $ eta syntax (
      singleStmt |
      first=singleStmt semicolon second=stmt { Seq (first, second) }
    );
   

-- Public top-level parser
public parse = stmt;
