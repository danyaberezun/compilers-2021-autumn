-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Expr;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun createBinop(l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x = decimal { Const (stringInt (x)) } |
                                 x = lident  { Var (x) }               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr ({
        [Left, { [s ("!!"), createBinop] }],

        [Left, { [s ("&&"), createBinop] }],

        [Nona, {
                 [s ("=="), createBinop],
                 [s ("!="), createBinop],
                 [s ("<"),  createBinop],
                 [s (">"),  createBinop],
                 [s ("<="), createBinop],
                 [s (">="), createBinop]
        }],

        [Left, {
                 [s ("+"),  createBinop],
                 [s ("-"),  createBinop]
        }],

        [Left, {
                 [s ("*"),  createBinop],
                 [s ("/"),  createBinop],
                 [s ("%"),  createBinop]
        }]
      }, primary);

var singleStmtParser = memo $ eta syntax (
    kRead toRead = inbr[s("("), lident, s(")")] { Read (toRead) }
  | kWrite expr  = inbr[s("("), exp,    s(")")] { Write (expr) }
  | ident        = lident s[":="] expr = exp    { Assn (ident, expr) }
  | kSkip { Skip }
);

var stmt = memo $ eta syntax (
    singleStmtParser
  | st1 = singleStmtParser s[";"] st2 = stmt { Seq (st1, st2) }
);

-- Public top-level parser
public parse = stmt;
