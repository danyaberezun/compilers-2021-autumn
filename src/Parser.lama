-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]);
                                 
fun createLevel(op) {
   [s(op), fun (l, op, r){Binop(op, l ,r)}]
}

-- precedence from the spec
var ops = {
  [Left, map(createLevel, {"!!"})],
  [Left, map(createLevel, {"&&"})],
  [Nona, map(createLevel, {"==", "!=", "<=", "<", ">=", ">"})],
  [Left, map(createLevel, {"+", "-"})],
  [Left, map(createLevel, {"*", "/", "%"})]
};

var exp = memo $ eta expr(ops, primary);

var elseOrSkip = memo $ eta syntax (
  -kElse stmt_seq | empty { Skip }
);

var thenStmt = memo $ eta syntax (
  condition=exp -kThen body=stmt_seq next=elseStmt { If(condition, body, next) }
);

var elseStmt = memo $ eta syntax (
  -kElif thenStmt | elseOrSkip
);


var stmt = memo $ eta syntax(
  varname=lident s[":="] expr_=exp {Assn(varname, expr_)} | 
  stmt1=stmt s[";"] stmt2=stmt end {Seq(stmt1, stmt2)} | 
  kSkip {Skip} | 
  kRead varname=inbr[s("("), lident, s(")")] {Read(varname)} | 
  kWrite expr_=inbr[s("("), exp, s(")")] {Write(expr_)} |
  -kIf thenStmt -kFi                                                         |
  -kWhile condition=exp -kDo body=stmt_seq -kOd { While(condition, body) }   |
  -kDo body=stmt_seq -kWhile condition=exp -kOd { DoWhile(body, condition) } |
  -kFor beforeAll=stmt_seq -s[","]
        condition=exp      -s[","]
        afterAll=stmt_seq  -kDo
    body=stmt_seq
  -kOd {
    Seq(beforeAll, While(condition, Seq(body, afterAll)))
  }
);

-- Public top-level parser
public parse = stmt;
