-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

fun wrapValue (v, loc) {
  fun (atr) {
    case atr of
      Val -> v
    | Weak -> v
    | Void -> Ignore (v)
    | Ref -> error ("Expected reference, got a plain value " ++ string (v), loc)
    esac
  }
}

fun wrapVoid (v, loc) {
  fun (atr) {
    case atr of
      Void -> v
    | Weak -> Seq (v, Const (0))
    | Val -> error ("Expected Val, got Void", loc)
    | Ref -> error ("Expected Ref, got Void", loc)
    esac
  }
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}
fun binop (op) {
  [
    syntax (pos -s[op]),
    fun (l, loc, r) {
      wrapValue (Binop (op, l (Val), r (Val)), loc)
    }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Assn (Ref (ident), value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Var (ds)      ->
                 case expandDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

fun makeIf (cases, finalE) {
  fun (atr) {
    case cases of
      {} -> finalE (atr)
    | [cond, branch] : otherCases ->
      If (cond (Val), branch (atr), makeIf (otherCases, finalE) (atr))
    esac
  }
}

var primary  = memo $ eta syntax (
  -- decimal constant
  loc=pos x=decimal {
    wrapValue (Const (stringInt (x)), loc)
  }
| -- an identifier or a function call
  loc=pos x=lident args=inbr[s ("("), list0(syntax(e=exp {e (Val)})), s (")")]? {
    case args of
      None -> -- variable reference
        fun (atr) {
          case atr of
            Ref  -> Ref (x)
          | Void -> Ignore (Var (x))
          | _    -> Var (x)
          esac
        }
    | Some (args) -> -- function call
        wrapValue (Call (x, args), loc)
    esac
  } 
| -- skip
  loc=pos -kSkip {
    wrapVoid (Skip, loc)
  }
| -- surrounded with brackets
  inbr[s ("("), scopeExpr, s (")")]
| -- if
  -kIf condE=exp
    -kThen thenE=scopeExpr
    elifBlocks=$(eta syntax (-kElif exp -kThen scopeExpr))*
    elseLoc=pos
    elseBlock=$(eta syntax (-kElse scopeExpr))?
  -kFi {
    var finalE = case elseBlock of
      Some (exp) -> exp
    | None -> wrapVoid (Skip, elseLoc)
    esac;
    makeIf ([condE, thenE] : elifBlocks, finalE)
  }
| -- while
  loc=pos -kWhile condE=exp kDo bodyE=scopeExpr -kOd {
    wrapVoid (While (condE (Val), bodyE (Void)), loc)
  }
| -- do-while
  loc=pos -kDo bodyE=scopeExpr -kWhile condE=exp kOd {
    var node = case bodyE (Void) of
      Scope (defs, bodyE) ->
        Scope (defs, DoWhile (bodyE, condE (Val)))
    | bodyE ->
        DoWhile (bodyE, condE (Val))
    esac;
    wrapVoid (node, loc)
  }
| -- read
  loc=pos -kRead s["("] v=lident s[")"] {
    wrapVoid (Read (v), loc)
  }
| -- write
  loc=pos -kWrite s["("] e=exp s[")"] {
    wrapVoid (Write (e (Val)), loc)
  }
| -- for
  loc=pos -kFor initE=scopeExpr s[","] condE=exp s[","] stepE=exp -kDo
  bodyE=scopeExpr
  -kOd {
    var loop = While (
      condE (Val),
      Seq (
        bodyE (Void),
        stepE (Void)
      )
    );
    var withInit = case initE (Void) of
      Scope (initDefs, initBody) ->
        Scope (initDefs, Seq (initBody, loop))
    | initE -> Seq (initE, loop)
    esac;
    wrapVoid (withInit, loc)
  }
);

var basic = memo $ eta (
  expr (
    {
      [Right, {
          [
            s (":="),
            fun (l, loc, r) {
              wrapValue (Assn (l (Ref), r (Val)), loc)
            }
          ]
        }
      ],
      [Left, map (binop, {"!!"})],
      [Left, map (binop, {"&&"})],
      [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
      [Left, map (binop, {"+", "-"})],
      [Left, map (binop, {"*", "/", "%"})]
    },
    primary
  )
);

var scopeExpr = memo $ eta syntax (
  ds=definition* e=exp? {
    var expr = case e of
      Some (e) -> e
    | None -> wrapVoid (Skip)
    esac;
    fun (atr) {
      var e = expr (atr);
      case ds of 
        {} -> e
      | _ -> expandScope (ds, e)
      esac
    }
  }
);

var definition = memo $ eta syntax(
  -- variable definition
  kVar ds=list[syntax (lident (s["="] e=basic {e (Val)})?)] s[";"] {
    Var (ds)
  }
| -- function definition
  kFun
  name=lident
  args=inbr[s ("("), list0 (lident), s (")")]
  body=inbr[s ("{"), scopeExpr, s ("}")] {
    Fun (name, args, body (Weak))
  }
);

var exp = memo $ eta syntax (
  basic
| s1=basic s[";"] s2=exp {
    fun (atr) {
      Seq (s1 (Void), s2 (atr))
    }
  }
);

-- Public top-level parser
public parse = syntax (
  s=scopeExpr {
    s (Void)
  }
);

