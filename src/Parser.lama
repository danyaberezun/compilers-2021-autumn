-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun buildBinop (op) {
  fun (l, o, r) {
    Binop (op, l, r)
  }
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const (stringInt (x)) } |
                                 x=lident  { Var (x) }               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        {
          [Left, {[s("!!"), buildBinop ("!!")]}],
          [Left, {[s("&&"), buildBinop ("&&")]}],
          [Left,
            {[s("=="), buildBinop ("==")],
             [s("!="), buildBinop ("!=")],
             [s("<" ), buildBinop ("<" )],
             [s("<="), buildBinop ("<=")],
             [s(">" ), buildBinop (">" )],
             [s(">="), buildBinop (">=")]
            }],
          [Left, 
            {[s("+"), buildBinop ("+")],
             [s("-"), buildBinop ("-")]
            }],
          [Left,
            {[s("*"), buildBinop ("*")],
             [s("/"), buildBinop ("/")],
             [s("%"), buildBinop ("%")]
            }]
        },
        primary
      );

var stmt = memo $ eta syntax (
    (kRead e=inbr[s("("), lident, s(")")] { Read  (e)   }) |
    (kWrite e=inbr[s("("), exp, s(")")]   { Write (e)   }) |
    (kSkip                                { Skip        }) |                             
    (v=lident s[":="] e=exp               { Assn (v, e) })
    );

var stmts = memo $ eta syntax (
    s=stmt                      { s            } |
    s1=stmt token[";"] s2=stmts { Seq (s1, s2) }
    );

-- Public top-level parser
public parse = stmts;
             