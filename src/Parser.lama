-- Parser 

import Ostap;
import Matcher;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


fun makeBinop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      
      exp = memo $ eta expr ({[Left, {[s("!!"), makeBinop]}], 
                              [Left, {[s("&&"), makeBinop]}], 
                              [Nona, {[s("==") | s("!=") | s(">=") | s("<=") | s("<") | s(">"), makeBinop]}], 
                              [Left, {[s("+")  | s("-"), makeBinop]}], 
                              [Left, {[s("*")  | s("/") | s("%"), makeBinop]}]}, primary);

var simple_statement = memo $ syntax (kSkip                                {Skip}        |
                                      kRead x=inbr[s("("), lident, s(")")] {Read(x)}     | 
                                      kWrite e=inbr[s("("), exp, s(")")]   {Write(e)}    |
                                      x=lident $(s(":=")) e=exp            {Assn(x, e)});

var stmt = memo $ syntax (simple_statement | left=simple_statement s[";"] remaining=stmt {Seq(left, remaining)});
   
-- Public top-level parser
public parse = stmt;
             
