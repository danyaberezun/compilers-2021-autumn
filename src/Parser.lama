-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun constructBinop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr ({
          [Left, {[s("!!"), constructBinop]}],
          [Left, {[s("&&"), constructBinop]}],
          [Nona, {[s("<"),  constructBinop],
                  [s("<="), constructBinop],
                  [s(">"),  constructBinop],
                  [s(">="), constructBinop],
                  [s("=="), constructBinop],
                  [s("!="), constructBinop]}],
          [Left, {[s("+"),  constructBinop],
                  [s("-"),  constructBinop]}],
          [Left, {[s("*"),  constructBinop],
                  [s("/"),  constructBinop],
                  [s("%"),  constructBinop]}]
        }, primary);

var endIf = memo $ eta syntax (
    kFi {Skip} 
  | kElse st=stmt kFi {st}
  | kElif e=exp kThen st=stmt falsePath=endIf {If (e, st, falsePath)}
);

var simpleStmt = memo $ eta syntax (
    kSkip                                 {Skip}        
  | x=lident s[":="] e=exp               {Assn (x, e)} 
  | kRead x=inbr[s("("), lident, s(")")] {Read (x)}    
  | kWrite e=inbr[s("("), exp, s(")")]   {Write (e)}   
  | kIf e=exp kThen st=stmt falsePath=endIf {If (e, st, falsePath)}
  | kWhile e=exp kDo st=stmt kOd {While (e, st)}
  | kDo st=stmt kWhile e=exp kOd {DoWhile(st, e)}
  | kFor st1=stmt s[","] e=exp s[","] st2=stmt kDo st3=stmt kOd {Seq (st1, While(e, Seq(st3, st2)))}
);

var stmt = memo $ eta syntax (simpleStmt | s1=simpleStmt s[";"] s2=stmt {Seq (s1, s2)});
   

-- Public top-level parser
public parse = stmt;
