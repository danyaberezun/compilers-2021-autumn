-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopParser (op) {
  [s (op), fun (l, op_, r) {Binop (op_, l, r)}]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                          x=lident {Var (x)} |
                          inbr [s ("("), exp, s (")")]),
    exp = memo $ eta (expr ({
                          [
                            Left,
                            {
                              binopParser("!!"),
                              binopParser("&&")
                            }
                          ],
                          [
                            Nona,
                            {
                              binopParser(">="),
                              binopParser(">"),
                              binopParser("<="),
                              binopParser("<"),
                              binopParser("=="),
                              binopParser("!=")
                            }
                          ],
                          [
                            Left,
                            {
                              binopParser("+"),
                              binopParser("-")
                            }
                          ],
                          [
                            Left,
                            {
                              binopParser("*"),
                              binopParser("/"),
                              binopParser("%")
                            }
                          ]
                        }, primary));

var stmt = memo $ eta syntax (kSkip                         {Skip}         |
                              x=lident s[":="] e=exp        {Assn (x, e)}  |
                              kRead s["("] x=lident s[")"]  {Read(x)}      |
                              kWrite s["("] e=exp s[")"]    {Write(e)}     |
                              kWhile e=exp kDo s=stmts kOd {While(e, s)}   |
                              kDo s=stmts kWhile e=exp kOd {DoWhile(s, e)} |
                              kIf s=ifParser kFi {s}                       |
                              kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s=stmts kOd {Seq(s1, While(e, Seq(s, s2)))}
                              ),
    ifParser = memo $ eta syntax (e=exp kThen s1=stmts s2=elseParser {If(e, s1, s2)}),
    elseParser = memo $ eta syntax (empty {Skip} | kElse s=stmts {s} | kElif s=ifParser {s});

var stmts = memo $ eta syntax (stmt | s1=stmt s[";"] s2=stmts {Seq(s1, s2)});

-- Public top-level parser
public parse = stmts;
