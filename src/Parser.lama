-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

fun wrapValue (v, loc) {
  fun (atr) {
    case atr of
      Val -> v
    | Void -> Ignore (v)
    | Ref -> error ("Expected reference, got a plain value " ++ string (v), loc)
    esac
  }
}

fun wrapVoid (v, loc) {
  fun (atr) {
    case atr of
      Void -> v
    | Val -> error ("Expected Val, got Void", loc)
    | Ref -> error ("Expected Ref, got Void", loc)
    esac
  }
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [
    syntax (pos -s[op]),
    fun (l, loc, r) {
      wrapValue (Binop (op, l (Val), r (Val)), loc)
    }
  ]
}

fun makeIf (cases, finalE) {
  fun (atr) {
    case cases of
      {} -> finalE (atr)
    | [cond, branch] : otherCases ->
      If (cond (Val), branch (atr), makeIf (otherCases, finalE) (atr))
    esac
  }
}

var primary  = memo $ eta syntax (
  -- decimal constant
  loc=pos x=decimal {
    wrapValue (Const (stringInt (x)), loc)
  }
| -- identifier
  x=lident {
    fun (atr) {
      case atr of
        Ref  -> Ref (x)
      | Void -> Ignore (Var (x))
      | _    -> Var (x)
      esac
    }
  } 
| -- skip
  loc=pos -kSkip {
    wrapVoid (Skip, loc)
  }
| -- surrouned with brackets
  inbr[s ("("), exp, s (")")]
| -- if
  -kIf condE=exp
    -kThen thenE=exp
    elifBlocks=$(eta syntax (-kElif exp -kThen exp))*
    elseLoc=pos
    elseBlock=$(eta syntax (-kElse exp))?
  -kFi {
    var finalE = case elseBlock of
      Some (exp) -> exp
    | None -> wrapVoid (Skip, elseLoc)
    esac;
    makeIf ([condE, thenE] : elifBlocks, finalE)
  }
| -- while
  loc=pos -kWhile condE=exp kDo bodyE=exp -kOd {
    wrapVoid (While (condE (Val), bodyE (Void)), loc)
  }
| -- do-while
  loc=pos -kDo bodyE=exp -kWhile condE=exp kOd {
    wrapVoid (DoWhile (bodyE (Void), condE (Val)), loc)
  }
| -- read
  loc=pos -kRead s["("] v=lident s[")"] {
    wrapVoid (Read (v), loc)
  }
| -- write
  loc=pos -kWrite s["("] e=exp s[")"] {
    wrapVoid (Write (e (Val)), loc)
  }
| -- for
  loc=pos -kFor initE=exp s[","] condE=exp s[","] stepE=exp -kDo
  bodyE=exp
  -kOd {
    wrapVoid (
      Seq (
        initE (Void),
        While (
          condE (Val),
          Seq (
            bodyE (Void),
            stepE (Void)
          )
        )
      ),
      loc
    )
  }
);

var basic = memo $ eta (
  expr (
    {
      [Right, {
          [
            s (":="),
            fun (l, loc, r) {
              wrapValue (Assn (l (Ref), r (Val)), loc)
            }
          ]
        }
      ],
      [Left, map (binop, {"!!"})],
      [Left, map (binop, {"&&"})],
      [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
      [Left, map (binop, {"+", "-"})],
      [Left, map (binop, {"*", "/", "%"})]
    },
    primary
  )
);
var exp = memo $ eta syntax (
  basic
| s1=basic s[";"] s2=exp {
    fun (atr) {
      Seq (s1 (Void), s2 (atr))
    }
  }
);

-- Public top-level parser
public parse = syntax (
  s=exp {
    s (Void)
  }
);
