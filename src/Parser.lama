-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
         {
          [Left, {[s("&&") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("!!"), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Nona, {[s("==") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("!="), fun (l, op, r) {Binop (op, l, r)}],
                [s(">"), fun (l, op, r) {Binop (op, l, r)}],
                [s("<"), fun (l, op, r) {Binop (op, l, r)}],
                [s(">="), fun (l, op, r) {Binop (op, l, r)}],
                [s("<="), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Left, {[s("+"), fun (l, op, r) {Binop (op, l, r)}] ,
                [s("-"), fun (l, op, r) {Binop (op, l, r)}]
                }],
          [Left, {[s("*") , fun (l, op, r) {Binop (op, l, r)}] ,
                [s("/"), fun (l, op, r) {Binop (op, l, r)}],
                [s("%"), fun (l, op, r) {Binop (op, l, r)}]
                }]
         }, primary);

var ifExprNoKeyword = memo $ eta syntax (
  x=exp kThen y=stmtList { If (x, y, Skip) } |
  x=exp kThen y=stmtList kElse z=stmtList { If (x, y, z) } |
  x=exp kThen y=stmtList kElif z=ifExprNoKeyword { If (x, y, z) }
);

var stmt = memo $ eta syntax (
  kIf c=exp kThen body=stmtList kElse body_else=stmtList kFi { If(c, body, body_else)} |
  kIf c=exp kThen body=stmtList kElif body_else=ifExprNoKeyword kFi { If(c, body, body_else)} |
  kIf c=exp kThen body=stmtList kFi { If(c, body, Skip)} |
  kWhile e=exp kDo body=stmtList kOd { While(e, body) } |
  kDo body=stmtList kWhile e=exp kOd { DoWhile(e, body) } |
  kFor init=stmt s[","] cond=exp s[","] inc=stmtList kDo body=stmtList kOd { Seq (init, While (cond, Seq (body, inc))) } |
  v=lident s[":="] e=exp { Assn(v, e) } |
  kSkip { Skip } |
  kRead v=inbr[s("("), lident, s(")")] { Read(v) } |
  kWrite v=exp { Write(v) }
);
   
var stmtList = eta syntax (
  l=stmt { l } |
  r=stmt s[";"] t=stmtList {Seq(r, t)}
);

-- Public top-level parser
public parse = stmtList;
             
