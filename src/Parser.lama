-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Stmt;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inbr[s("("), exp, s(")")]
);

fun toBinop (l, op, r) {
  Binop (op, l, r)
}

var exp = memo $ expr (
  {
    [Left, {
      [s ("!!"), toBinop]
    }],
    [Left, {
      [s ("&&"), toBinop]
    }],
    [Nona, {
      [s ("=="), toBinop],
      [s ("!="), toBinop],
      [s ("<="), toBinop],
      [s ("<"), toBinop],
      [s (">="), toBinop],
      [s (">"), toBinop]
    }],
    [Left, {
      [s ("+"), toBinop],
      [s ("-"), toBinop]
    }],
    [Left, {
      [s ("*"), toBinop],
      [s ("/"), toBinop],
      [s ("%"), toBinop]
    }]
  },
  primary
);

fun makeIf (cases, finalStmt) {
  case cases of
    {} ->
      finalStmt
  | [cond, branch] : otherCases ->
      If (cond, branch, makeIf (otherCases, finalStmt))
  esac
}

var primaryStmt = memo $ eta syntax (
  v=lident s[":="] e=exp {
    Assn (v, e)
  } |
  kSkip {Skip} |
  kRead s["("] v=lident s[")"] {
    Read (v)
  } |
  kWrite s["("] e=exp s[")"] {
    Write (e)
  } |
  kIf cond=exp
    kThen thenStmt=stmt 
    elifBlocks=$(eta syntax (-kElif exp -kThen stmt))*
    elseBlock=$(eta syntax (-kElse stmt))?
  kFi {
    var finalStmt = stmtOrSkip (elseBlock);
    makeIf ([cond, thenStmt] : elifBlocks, finalStmt)
  } |
  kWhile cond=exp kDo bodyStmt=stmt kOd {
    While (cond, bodyStmt)
  } |
  kDo bodyStmt=stmt kWhile cond=exp kOd {
    DoWhile (bodyStmt, cond)
  } |
  kFor init=stmt? s[","] cond=exp s[","] step=stmt kDo body=stmt kOd {
    For (stmtOrSkip (init), cond, step, body)
  }
);

var stmt = memo $ expr (
  {
    [Left, {
      [s (";"), fun (l, _, r) { Seq (l, r) }]
    }]
  },
  primaryStmt
);

-- Public top-level parser
public parse = stmt;
             
