-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inparens(p) {
  inbr(s("("), p, s(")"))
}

fun binop(l, op, r) {Binop (op, l, r)}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inparens[exp]
);

var exp = memo $ eta expr({
  [Left, {
    [s ("!!"), binop]
  }],
  [Left, {
    [s ("&&"), binop]
  }],
  [Nona, {
    [s ("=="), binop],
    [s ("!="), binop],
    [s ("<" ), binop],
    [s ("<="), binop],
    [s (">" ), binop],
    [s (">="), binop]
  }],
  [Left, {
      [s ("+"), binop],
      [s ("-"), binop]
  }],
  [Left, {
      [s ("*") , binop],
      [s ("/") , binop],
      [s ("%") , binop]
  }]
}, primary);

var stmt_ = memo $ eta syntax (
  kRead  x=inparens[lident] {Read(x)}    |
  kWrite x=inparens[exp]    {Write(x)}   |
  kSkip                     {Skip}       |
  x=lident s[":="] e=exp    {Assn(x, e)}
);

var stmt = memo $ eta syntax(h=stmt_ t=(-s[";"] stmt_)* { foldr(fun (acc, x) { Seq(x, acc) }, Skip, h:t) });

-- Public top-level parser
public parse = stmt;
