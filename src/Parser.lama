-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopWrapper (l, op, r) {
  Binop (op, l, r)
}

fun opBuilder(assoc, op) {
  [assoc, {[op, binopWrapper]}]
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (expr 
        (
          {
            opBuilder (Left, s ("!!")),
            opBuilder (Left, s ("&&")),
            opBuilder (Nona, s ("==") | s ("!=") | s ("<=") | s ("<") | s (">=") | s (">")),
            opBuilder (Left, s ("+") | s ("-")),
            opBuilder (Left, s ("*") | s ("/") | s ("%"))
          },
          primary
        ));

fun brackets(p) {
  inbr (s ("("), p, s (")"))
}

var basicStmt = memo $ eta (syntax 
  (
    kSkip { Skip }
  | kRead x=brackets[lident] {Read (x)}
  | kWrite x=brackets[exp] {Write (x)}
  | to=lident s[":="] x=exp {Assn (to, x)}
  | kIf x=exp kThen t=stmt e=ifRec {If (x, t, e)}
  | kWhile x=exp kDo t=stmt kOd {While (x, t)}
  | kDo t=stmt kWhile x=exp kOd {DoWhile (t, x)}
  | kFor i=stmt s[","] x=exp s[","] s=stmt kDo t=stmt kOd {Seq (i, While (x, Seq (t, s)))}
  )),
  ifRec = memo $ eta (syntax (kElif x=exp kThen t=stmt e=ifRec {If (x, t, e)} | kElse t=stmt kFi {t} | kFi {Skip})), 
  stmt = memo $ eta (syntax (l=basicStmt s[";"] r=stmt {Seq (l, r)} | basicStmt));
   

-- Public top-level parser
public parse = stmt;
