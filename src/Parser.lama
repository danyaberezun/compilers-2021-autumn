-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binopRun(left, op, right) {
  Binop (op, left, right)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr(
        {
          [Left, {[s ("!!"), binopRun]}],
          [Left, {[s ("&&"), binopRun]}],
          [Nona, {[s ("=="), binopRun]}],
          [Nona, {[s ("!="), binopRun]}],
          [Nona, {[s ("<="), binopRun]}],
          [Nona, {[s ("<"), binopRun]}],
          [Nona, {[s (">="), binopRun]}],
          [Nona, {[s (">"), binopRun]}],
          [Left, {[s ("+"), binopRun]}],
          [Left, {[s ("-"), binopRun]}],
          [Left, {[s ("*"), binopRun]}],
          [Left, {[s ("/"), binopRun]}],
          [Left, {[s ("%"), binopRun]}]
        },
        primary
      );

fun bracketsAdd(t) {
  inbr (s ("("), t, s (")"))
}

var baseStmt = memo $ eta syntax
  (
    kSkip { Skip }
  | kRead x = bracketsAdd [lident] { Read(x) }
  | kWrite x = bracketsAdd [exp] { Write(x) }
  | to = lident s[":="] x = exp { Assn (to, x) }
  ),
  stmt = memo $ eta syntax (
    l = baseStmt s[";"]
    r = stmt { Seq(l, r) } | baseStmt
  );

-- Public top-level parser
public parse = stmt;

