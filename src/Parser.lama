-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var disj = s ("!!");
var conj = s ("&&");
var comp = s ("==") | s ("!=") | s ("<=") | s ("<") | s (">=") | s (">");
var ops1 = s ("+") | s ("-");
var ops2 = s ("*") | s ("/") | s ("%");

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        {[Left, {[disj, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[conj, fun (l, op, r) {Binop (op, l, r)}]}],
         [Nona, {[comp, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[ops1, fun (l, op, r) {Binop (op, l, r)}]}],
         [Left, {[ops2, fun (l, op, r) {Binop (op, l, r)}]}]}, primary);

var rAssn = memo $ eta expr ({[Right, {[s (":="), fun (l, op, r) {Seq (l, r)}]}]}, stmt);

var stmt = memo $ eta syntax (kSkip {Skip} |
                              kRead i=inbr[s("("), lident, s(")")] {Read (i)} |
                              kWrite x=inbr[s("("), exp, s(")")] {Write (x)} |
                              i=lident s[":="] x=exp {Assn (i, x)});

var stmts = memo $ eta expr ({[Left, {[s (";"), fun (l, op, r) {Seq (l, r)}]}]}, stmt);
   

-- Public top-level parser
public parse = stmts;
             
