-- Parser
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax(-l p -r)
}

fun binaryOperation(op) {
  [s(op), fun(l, _, r) { Binop(op, l ,r) }]
}

-- Primary expression
var primary = memo $ eta(
  decimal @ fun(x) { Const(stringInt(x)) }
  | lident @ fun(x) { Var(x) }
  | inbr(s("("), expression, s(")"))
);

var expression = memo $ eta(
  expr(
    {
      [Left, { binaryOperation("!!") }],
      [Left, { binaryOperation("&&") }],
      [Nona, map(binaryOperation, { "==", "!=", ">", "<", ">=", "<=" })],
      [Left, map(binaryOperation, { "+", "-" })],
      [Left, map(binaryOperation, { "*", "/", "%" })]
    },
    primary
  )
);

var ifStatement = memo $ eta syntax(
    empty { Skip }
    | kElse elseBody = statement { elseBody }
    | kElif condition = expression kThen s1 = statement elseBody = ifStatement
      { If(condition, s1, elseBody) }
  );

var separateStatement = memo $ eta syntax(
  kSkip { Skip }
  | kRead variable = inbr [s("("), lident, s(")")] { Read(variable) }
  | kWrite value = inbr [s("("), expression, s(")")] { Write(value) }
  | variable = lident s [":="] value = expression { Assn(variable, value) }
  | kWhile condition = expression kDo body = statement kOd { While(condition, body) }
  | kDo body = statement kWhile condition = expression kOd { DoWhile(body, condition) }
  | kFor initialization = statement s[","] condition = expression s[","]
    increment = statement kDo body = statement kOd
    { Seq(initialization, While(condition, Seq(body, increment))) }
  | kIf condition = expression kThen thenBody = statement elseBody = ifStatement kFi
    { If(condition, thenBody, elseBody) }
);


var statement = memo $ eta syntax(
  separateStatement
  | left = separateStatement s [";"] right = statement { Seq(left, right) }
);

-- Public top-level parser
public parse = statement;
