-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binOpConverter (op) {
  [s(op), fun(l, _, r) { Binop(op, l, r) }]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (
        {
        [Left, map(binOpConverter, {"!!"})],
        [Left, map(binOpConverter, {"&&"})],
        [Nona, map(binOpConverter, {"<", ">", ">=", "<=", "==", "!="})],
        [Left, map(binOpConverter, {"+", "-"})],
        [Left, map(binOpConverter, {"*", "/", "%"})]
        }, primary);

var singleLine = memo $ eta syntax
(
  kRead x = inbr[s("("), lident, s(")")] { Read (x) } |
  kWrite x = inbr[s("("), exp, s(")")] { Write (x) } |
  kSkip { Skip } |
  x = lident s[":="] y = exp { Assn(x, y) }
);

var stmts = memo $ eta syntax
(
  singleLine |
  stmt = singleLine s[";"] rest = stmts { Seq(stmt, rest) }
);

-- Public top-level parser
public parse = stmts;

