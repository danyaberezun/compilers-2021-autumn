-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parens (p) {
  syntax (inbr[s("("), p, s(")")])
}

fun binops (ops) {
  map (fun (op) { [s (op), fun (l, _, r) { Binop (op, l, r) }] }, ops)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 parens[exp]),
    exp = memo $ eta expr ({[Left, binops ({ "!!" })],
                            [Left, binops({ "&&" })],
                            [Nona, binops({ "==", "!=", ">", ">=", "<", "<=" })],
                            [Left, binops({ "+", "-" })],
                            [Left, binops({ "*", "/", "%" })]
                           }, primary);

var stmtSeq = memo $ eta syntax (kSkip                   {Skip}         |
                                 v=lident s[":="] ex=exp {Assn (v, ex)} |
                                 kRead v=parens[lident]  {Read (v)}     |
                                 kWrite x=parens[exp]    {Write (x)}),
    stmt = memo $ eta syntax (stmtSeq |
                              fst=stmtSeq s[";"] snd=stmt {Seq (fst, snd)});
   

-- Public top-level parser
public parse = stmt;
             
