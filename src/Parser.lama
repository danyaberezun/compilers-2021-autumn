-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inParentheses(p) {
  inbr (s ("("), p, s (")"))
}

fun foldl1 (f, l) {
  case l of
    head:tail -> foldl(f, head, tail)
  | _         -> failure ("List is empty")
  esac
}

fun binopLayout(assoc, ops) {
  fun makeRule (ops) {
    foldl1 (alt, map (fun (op) { s (op) }, ops))
  }
  fun toBinop (left, op, right) {
    Binop (op, left, right)
  }
  [assoc, {[makeRule (ops), toBinop]}]
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (expr ({
        binopLayout (Left, {"!!"}),
        binopLayout (Left, {"&&"}),
        binopLayout (Nona, {"==", "<", ">", "!=", ">=", "<="}),
        binopLayout (Left, {"+", "-"}),
        binopLayout (Left, {"*", "/", "%"})
      }, primary));

var semicolon = memo $ eta (s (";")),
    equals = memo $ eta (s (":="));

var stmt = memo $ eta syntax (
  kRead name=inParentheses[lident] { Read (name) } |
  kWrite value=inParentheses[exp] { Write (value) } |
  name=lident equals value=exp { Assn (name, value) } |
  kSkip { Skip } |
  first=stmt semicolon second=stmt end { Seq (first, second) }
);
   

-- Public top-level parser
public parse = stmt;
