-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Utility;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

fun fitRef (context, v, loc) {
  case context of
    Void -> Ignore (Var (v))
  | Val  -> Var (v)
  | Ref  -> Ref (v)
  esac
}

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun fitVal (context, v, loc) {
  case context of
    Void -> Ignore (v)
  | Val  -> v
  | Ref  -> error ("reference expected", loc)
  esac
}

fun fitVoid (context, v, loc) {
  case context of
    Void -> v
  | Val  -> error ("value expected", loc)
  | Ref  -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun procBinops (binops) {
  fun makeBinop (l, [loc, op], r) {
    fun (context) {
      var parsed = case op of
        ":=" -> Assn (l (Ref), r (Val))
      | _    -> Binop (op, l (Val), r (Val))
      esac;
      fitVal (context, parsed, loc)
    }
  }

  fun procBinop (op) {
    [syntax (pos s[op]), makeBinop]
  }

  fun procBinopGroup ([assoc, ops]) {
    [assoc, map (procBinop, ops)]
  }

  map (procBinopGroup, binops)
}

var binops = procBinops ({
  [Right, {":="}],
  [Left,  {"!!"}],
  [Left,  {"&&"}],
  [Nona,  {"==", "!=", "<", "<=", ">", ">="}],
  [Left,  {"+", "-"}],
  [Left,  {"*", "/", "%"}]
});

-- Parens utility parser
var lParens = memo $ eta (s ("("));
var rParens = memo $ eta (s (")"));
fun parens (p) {
  inbr (lParens, p, rParens)
}

-- Utility parsers
var comma = memo $ eta (s (","));
var semicolon = memo $ eta (s (";"));

-- Decimal expression
var eDecimal = memo $ eta syntax (
  loc=pos x=decimal 
  {fun (a) {
      fitVal (a, Const (stringInt (x)), loc)
  }}
);

-- Identifier expression
var eIdentifier = memo $ eta syntax (
  loc=pos x=lident 
  {fun (a) {
      fitRef (a, x, loc)
  }}
);

-- Read expression
var eRead = memo $ eta syntax(
  loc=pos kRead eIdent=parens[exp]
  {fun (a) {
    fitVoid (a, Read (eIdent (Ref)), loc)
  }}
);

-- Write expression
var eWrite = memo $ eta syntax(
  loc=pos kWrite eVal=parens[exp]
  {fun (a) {
    fitVoid (a, Write (eVal (Val)), loc)
  }}
);

-- Skip expression
var eSkip = memo $ eta syntax(
  loc=pos kSkip
  {fun (a) {
    fitVoid (a, Skip, loc)
  }}
);

-- If expression
fun halfIf (expr, thenStmt) {
  fun (elseStmt) {
    If (expr, thenStmt, elseStmt)
  }
}
fun accum (a) {
  fun (stmt, halfIf) {
    halfIf (a) (stmt)
  }
}
var ifP = memo $ eta syntax (
  kIf e=exp kThen eThen=exp
  {fun (a) { 
    halfIf (e (Val), eThen (a)) 
  }}
);
var elifP = memo $ eta syntax (
  kElif e=exp kThen eThen=exp
  {fun (a) {
    halfIf (e (Val), eThen (a)) 
  }}
);
var elseP = memo $ eta syntax (
  loc=pos s=(-kElse exp)? 
  {fun (a) {
    case s of
      Some (s) -> s (a)
    | None     -> fitVoid (a, Skip, loc)
    esac
  }}
);
var eIf = memo $ eta syntax (
  sThen=ifP sElif=elifP* sElse=elseP kFi 
  {fun (a) {
    foldr (accum (a), sElse (a), sThen:sElif)
  }}
);

-- While expression
var eWhile = memo $ eta syntax (
  loc=pos kWhile eCond=exp kDo eBody=exp kOd 
  {fun (a) {
    fitVoid (a, While (eCond (Val), eBody (Void)), loc)
  }}
);

-- For expression
var eFor = memo $ eta syntax (
  loc=pos kFor eInit=exp comma eCond=exp comma eCounter=exp kDo eBody=exp kOd
  {fun (a) {
    var expr = Seq (eInit (Void), 
                    While (eCond (Val), 
                           Seq (eBody (Void), 
                                eCounter (Void))));
    fitVoid (a, expr, loc)
  }}
);

-- Do-While expression
var eDoWhile = memo $ eta syntax (
  loc=pos kDo eBody=exp kWhile eCond=exp kOd 
  {fun (a) {
    DoWhile (eBody (Void), eCond (Val)) 
  }}
);

var primary = memo $ eta syntax (
  parens[exp]
| eDecimal
| eIdentifier
| eIf
| eWhile
| eFor
| eDoWhile
| eRead
| eWrite
| eSkip
);

var basic = memo $ eta (expr (binops, primary));

var exp = memo $ eta syntax (
  basic 
| s1=basic semicolon s2=exp 
  {fun (a) {
      Seq (s1 (Void), s2 (a))
  }}
);

-- Full program
var program = memo $ eta syntax (s=exp -end {s (Void)});

-- Public top-level parser
public parse = program;
