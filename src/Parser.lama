-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun fbop(l, op, r) { Binop(op, l, r) }

fun bopify(o) {
  [s (o), fbop]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      -- opf = fun (l, or, r)
      exp = expr(
          { [ Left, { bopify ("!!") } ]
          , [ Left, { bopify ("&&") } ]
          , [ Nona, map(bopify, { "==", "!=", "<=", ">=", "<", ">" }) ]
          , [ Left, map(bopify, { "+", "-" }) ]
          , [ Left, map(bopify, { "*", "/", "%" }) ]
          }
        , primary);

fun exact (a) {
  syntax (a)
}

fun inbr2 (p) {
  syntax (inbr[s("("), p, s(")")])
}

var stmt1 = memo $ eta syntax (x=kSkip {Skip} |
                               x=kRead y=inbr2[lident] {Read (y)} |
                               x=kWrite y=inbr2[exp] {Write (y)} |
                               x=lident y=s[":="] z=exp {Assn (x, z)}
                              );
var stmt = memo $ eta syntax (x=stmt1 s[";"] y=stmt { Seq (x, y) } |
                              stmt1
                             );

-- Public top-level parser
public parse = stmt;
             
