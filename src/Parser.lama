-- Parser

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(left, parser, right) {
  syntax (-left parser -right)
}

-- Primary expression
var primary = memo $ eta syntax (
  constant = decimal { Const(stringInt(constant)) } |
  variable = lident  { Var(variable) }              |
  inbr[s("("), exp, s(")")]
);

fun binMapper(opName) {
  [s(opName), fun (left, _, right) { Binop(opName, left, right) }]
}

var exp = memo $ eta (expr({
  [Left, { binMapper("!!") }],
  [Left, { binMapper("&&") }],
  [Nona, map(binMapper, { "<", ">", "<=", ">=", "==", "!=" })],
  [Left, map(binMapper, { "+", "-" })],
  [Left, map(binMapper, { "*", "/", "%" })]
}, primary));

var stmt = memo $ eta syntax (v = lident s[":="] e = exp { Assn(v, e) }            |
  kSkip { Skip }                                    |
  kRead v = inbr[s("("), lident, s(")")] { Read(v) } |
  kWrite e = inbr[s("("), exp, s(")")] { Write(e) }  |
  kWhile e = exp kDo s = block kOd { While(e, s) } |
  kDo s = block kWhile e = exp kOd { DoWhile(s, e) } |
  kFor vars = block s[","] cond = exp s[","] afterAll = block kDo body = block kOd { Seq(vars, While(cond, Seq(body, afterAll))) } |
  kIf e = exp kThen s1 = block s2 = if_else kFi { If(e, s1, s2) }),
    if_else = memo $ eta syntax (
    empty { Skip } |
    kElse s = block { s } |
    kElif e = exp kThen s1 = block s2 = if_else { If(e, s1, s2) });


var block = memo $ eta syntax (stmt | line = stmt s[";"] tail = block { Seq(line, tail) });

-- Public top-level parser
public parse = block;
