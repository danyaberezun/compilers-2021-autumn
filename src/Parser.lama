-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun fbop(l, op, r) { Binop(op, l, r) }

fun bopify(o) {
  [s (o), fbop]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      -- opf = fun (l, or, r)
      exp = expr(
          { [ Left, { bopify ("!!") } ]
          , [ Left, { bopify ("&&") } ]
          , [ Nona, map(bopify, { "==", "!=", "<=", ">=", "<", ">" }) ]
          , [ Left, map(bopify, { "+", "-" }) ]
          , [ Left, map(bopify, { "*", "/", "%" }) ]
          }
        , primary);

fun exact (a) {
  syntax (a)
}

fun inbr2 (p) {
  syntax (inbr[s("("), p, s(")")])
}

var
  elsePart = memo $ eta syntax (kElse f=stmt kFi { Some (f) } |
                                kElif f=someIf { Some (f) } |
                                kFi { None } ),
  someIf = memo $ eta syntax (e=exp kThen t=stmt f=elsePart { If(e, t, f) });


var stmt1 = memo $ eta syntax (kSkip {Skip} |
                               kRead y=inbr2[lident] {Read (y)} |
                               kWrite y=inbr2[exp] {Write (y)} |
                               x=lident s[":="] z=exp {Assn (x, z)} |
                               kWhile e=exp kDo s=stmt kOd {While (e, s)} |
                               kDo s=stmt kWhile e=exp kOd {DoWhile (s, e)} |
                               kFor pre=stmt s[","] check=exp s[","] aft=stmt kDo body=stmt kOd {Seq (pre, While (check, Seq (body, aft)))} |
                               kIf i=someIf {i}
                              );
var stmt = memo $ eta syntax (x=stmt1 s[";"] y=stmt { Seq (x, y) } |
                              stmt1
                             );

-- Public top-level parser
public parse = stmt;
