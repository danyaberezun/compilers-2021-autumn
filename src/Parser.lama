-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inbr[s("("), exp, s(")")]
);

fun toBinop (l, op, r) {
  Binop (op, l, r)
}

var exp = memo $ expr (
  {
    [Left, {
      [s ("!!"), toBinop]
    }],
    [Left, {
      [s ("&&"), toBinop]
    }],
    [Nona, {
      [s ("=="), toBinop],
      [s ("!="), toBinop],
      [s ("<="), toBinop],
      [s ("<"), toBinop],
      [s (">="), toBinop],
      [s (">"), toBinop]
    }],
    [Left, {
      [s ("+"), toBinop],
      [s ("-"), toBinop]
    }],
    [Left, {
      [s ("*"), toBinop],
      [s ("/"), toBinop],
      [s ("%"), toBinop]
    }]
  },
  primary
);

var primaryStmt = memo $ eta syntax (
  v=lident s[":="] e=exp {
    Assn (v, e)
  } |
  kSkip {Skip} |
  kRead s["("] v=lident s[")"] {
    Read (v)
  } |
  kWrite s["("] e=exp s[")"] {
    Write (e)
  }
);

var stmt = memo $ expr (
  {
    [Left, {
      [s (";"), fun (l, _, r) { Seq (l, r) }]
    }]
  },
  primaryStmt
);

-- Public top-level parser
public parse = stmt;
             
