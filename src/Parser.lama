-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun makeBinop(l, op, r) {
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr ({
        [Left, {[s ("!!"), makeBinop]}],
        [Left, {[s ("&&"), makeBinop]}],
        [Nona, {[s ("==") | s ("!=") | s ("<=") |
                 s ("<") | s (">=") | s (">"), makeBinop]}],
        [Left, {[s ("+") | s ("-"), makeBinop]}],
        [Left, {[s ("*") | s ("/") | s ("%"), makeBinop]}]
      }, primary);

var ifStmt = memo $ eta syntax (
  e=exp -kThen s1=stmts -kFi                  { If (e, s1, Skip) } |
  e=exp -kThen s1=stmts -kElif s2=ifStmt      { If (e, s1, s2) }   |
  e=exp -kThen s1=stmts -kElse s2=stmts -kFi  { If (e, s1, s2) }   |
);

var stmt = memo $ eta syntax (
  x=lident -s[":="] e=exp                         { Assn (x, e) }                  | 
  -kSkip                                          { Skip }                         |
  -kRead x=inbr[s("("), lident, s(")")]           { Read (x) }                     |
  -kWrite e=inbr[s("("), exp, s(")")]             { Write (e) }                    | 
  -kIf -ifStmt                                                                     |
  -kWhile e=exp -kDo s=stmts -kOd                 { While (e, s) }                 |
  -kDo s=stmts -kWhile e=exp -kOd                 { DoWhile (s, e) }               |
  -kFor init=stmts s[","] e=exp s[","] 
        next=stmts kDo body=stmts                 { Seq(init, While(body, next)) }
);

var stmts = memo $ eta syntax (
  stmt | 
  l=stmt -s[";"] r=stmts  { Seq(l, r) }
);
   

-- Public top-level parser
public parse = stmts;
             