-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop(l, op, r) {
  Binop(op, l, r)
}

var operations = {
  [Left, "&&":{}],
  [Left, "!!":{}],
  [Nona, {"==", "<=", "<", ">=", ">", "!="}], -- left assoc is not needed
  [Left, {"+", "-"}],
  [Left, {"*", "/", "%"}]
};

fun mapper([assosiation, opData]) {
    [assosiation, map(fun (currOp) {
       [s(currOp), binop]
    }, opData)]
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr (map(mapper, operations), primary);


var elseBlock = memo $ eta syntax (kElif cond=exp kThen tb=stmts fb=elseBlock { If (cond, tb, fb) } |
                                  kElse stt=stmts { stt } |
                                  empty { Skip } );


var atomicStmt = memo $ eta syntax (kRead x=inbr[ s("("), lident, s(")") ] { Read(x) } |
                                     kWrite x=inbr[ s("("), exp, s(")") ]  { Write(x) } |
                                     x=lident s[":="] e=exp { Assn (x, e) } |
                                     kWhile cond=exp kDo stt=stmts kOd  { While (cond, stt) } |
                                     kIf cond=exp kThen tb=stmts fb=elseBlock kFi { If (cond, tb, fb) } |
                                     kDo stt=stmts kWhile cond=exp kOd { DoWhile (stt, cond) } |
                                     -- for init, cond, delta {block} --> init; while (cond) {block; delta;}
                                     kFor initSt=stmts s[","] cond=exp s[","] deltaSt=stmts
                                        kDo blockStmt=stmts kOd { Seq(initSt, While (cond, Seq(blockStmt, deltaSt))) } |
                                     kSkip { Skip } ),
        stmts = memo $ eta syntax (l=atomicStmt s[";"] r=stmts { Seq(l, r) } |
                                    atomicStmt);

-- Public top-level parser
public parse = stmts;
