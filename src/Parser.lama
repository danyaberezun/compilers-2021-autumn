-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binops() {
  var ops = {
    [Left, {"!!"}],
    [Left, {"&&"}],
    [Nona, {"==", "!=", "<=", "<", ">=", ">"}],
    [Left, {"+", "-"}],
    [Left, {"*", "/", "%"}]
  };
  
  fun prefBinop (x, op, y) {
    Binop (op, x, y)
  }

  fun binop (assoc, ops) {
    [assoc,
     map (fun (op) { [s (op), prefBinop] }, ops)
    ]
  }
  
  map (fun ([assoc, lops]) { binop (assoc, lops) }, ops)
}

-- Primary expression
var primary = memo $ eta syntax 
            (  
              x=decimal { Const (stringInt (x)) } |
              x=lident  { Var (x) }               |
              inbr[s ("("), exp, s (")")]
            ),
    exp     = memo $ eta (expr (binops (), primary));

var stmt    = memo $ eta syntax 
            (
              x=lident s[":="] e=exp                    { Assn (x, e)     } |
              kSkip                                     { Skip            } |
              kRead  x=inbr[s ("("), lident, s (")")]   { Read  (x)       } |
              kWrite x=inbr[s ("("), exp   , s (")")]   { Write (x)       } |
              kIf    e=exp   kThen  s=stmts         kFi { If (e, s, Skip) } |
              kIf    e=exp   kThen  s=stmts  or=els kFi { If (e, s, or)   } |
              kWhile e=exp   kDo    s=stmts         kOd { While   (e, s)  } |
              kDo    s=stmts kWhile e=exp           kOd { DoWhile (s, e)  } |
              kFor   i=stmt  s[","] e=exp s[","] s=stmt
              kDo    b=stmts kOd         { Seq (i, While (e, Seq (b, s))) }
            ),
    els     = memo $ eta syntax 
            (
              kElif  e=exp   kThen  s=stmts or=els      { If (e, s, or)   } |
              kElif  e=exp   kThen  s=stmts             { If (e, s, Skip) } |
              kElse  s=stmts                            { s               }
            ),
    stmts   = syntax
            (
              stmt |
              x=stmt token[";"] y=stmts { Seq (x, y) }
            );

-- Public top-level parser
public parse = stmts;
