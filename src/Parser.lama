-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]);
                                 
fun createLevel(op) {
   [s(op), fun (l, op, r){Binop(op, l ,r)}]
}

-- precedence from the spec
var ops = {
  [Left, map(createLevel, {"!!"})],
  [Left, map(createLevel, {"&&"})],
  [Nona, map(createLevel, {"==", "!=", "<=", "<", ">=", ">"})],
  [Left, map(createLevel, {"+", "-"})],
  [Left, map(createLevel, {"*", "/", "%"})]
};

var exp = memo $ eta expr(ops, primary);

var elseBody = memo $ eta syntax (
    kElse elseSt=stmt kFi { elseSt }
  | kElif ifSt=ifBody { ifSt }
  | kFi { Skip }
);

var ifBody = memo $ eta syntax (
  expr=exp kThen thenSt=stmt elseSt=elseBody { If (expr, thenSt, elseSt) }
);

var stmtSimple = memo $ eta syntax(
  varname=lident s[":="] expr_=exp {Assn(varname, expr_)} |
  kSkip {Skip} |
  kRead varname=inbr[s("("), lident, s(")")] {Read(varname)} |
  kWrite expr_=inbr[s("("), exp, s(")")] {Write(expr_)} |
  kIf ifSt=ifBody { ifSt } |
  kWhile cond=exp kDo bodyStmt=stmt kOd { While (cond, bodyStmt) } |
  kDo bodyStmt=stmt kWhile cond=exp kOd { DoWhile (bodyStmt, cond) } |
  kFor initStmt=stmt s[","] cond=exp s[","] updStmt=stmt kDo bodyStmt=stmt kOd { Seq (initStmt, While (cond, Seq (bodyStmt, updStmt))) }
);

var stmt = memo $ eta syntax (
  stmtSimple |
  stmt1=stmtSimple s[";"] stmt2=stmt { Seq (stmt1, stmt2) }
);

-- Public top-level parser
public parse = stmt;
