-- Parser
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error(msg, loc) {
  failure("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value(aka "rvalue")
--   Ref  --- a reference to a mutable cell(aka "lvalue")
--   Void --- no value(aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue(atr, v, loc) {
  case atr of
      Ref  -> error("reference expected", loc)
    | Void -> Ignore(v)
    | _    -> v
  esac
}

fun assertVoid(atr, v, loc) {
  case atr of
      Void -> v
    | Val  -> error("value expected", loc)
    | Weak -> Seq(v, Const(0))
    | _    -> error("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax(-l p -r)
}

fun bracketed(p) {
  inbr(s ("("), p, s (")"))
}

-- A helper function to be used with super-combinator "expr"
fun binop(op) {
  [
    syntax(pos -s[op]),
    fun(l, loc, r) {
      fun(a) {
        assertValue(a, Binop(op, l(Val), r(Val)), loc)
      }
    }
  ]
}

-- Helper parser: parses a(possible empty) list of items separated by ","
fun list0(item) {
  list0By(item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list(item) {
  listBy(item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope(defs, expr) {
  fun expandDefs(defs, expr) {
    foldr(
      fun([defs, expr], def) {
        case def of
          [ident, None]        -> [ident : defs, expr]
        | [ident, Some(value)] -> [ident : defs, Seq(Ignore(Assn(Ref(ident), value)), expr)]
        esac
      },
      [{}, expr],
      defs
    )
  }

  case
    foldr(
      fun([defs, expr], def) {
        case def of
          f@Fun(_, _, _) -> [f : defs, expr]
        | Var(ds)      ->
            case expandDefs(ds, expr) of
              [ds, expr] -> [Var(ds) : defs, expr]
            esac
        esac
      },
      [{}, expr],
      defs
    ) of [defs, expr] -> Scope(defs, expr)
  esac
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope(expr, exprConstructor) {
  case expr of
    Scope(defs, sexpr) -> Scope(defs, exprConstructor(sexpr))
  | _                  -> exprConstructor(expr)
  esac
}

var primary = memo $ eta syntax (
  loc = pos n = decimal { fun(a) { assertValue(a, Const(stringInt(n)), loc) } }
  | loc = pos func = lident args = bracketed[list0(argParser)]
    { fun(a) { assertValue(a, Call(func, args), loc) } }
  | loc = pos x = lident {
    fun(a) {
      case a of
        Ref -> Ref(x)
      | Void -> Ignore(Var(x))
      | _ -> Var(x)
      esac
    }
  }
  | loc = pos kSkip { fun(a) { assertVoid(a, Skip, loc) } }
  | loc = pos kRead e = bracketed[exp] { fun(a) { assertVoid(a, Read(e(Ref)), loc) } }
  | loc = pos kWrite e = bracketed[exp] { fun(a) { assertVoid(a, Write(e(Val)), loc) } }
  | kIf cond = exp kThen body = scopeExpr elseTail = elsePart
    { fun(a) { If(cond(Val), body(a), elseTail(a)) } }
  | loc = pos kWhile cond = exp kDo body = scopeExpr kOd
    { fun(a) { assertVoid(a, While(cond(Val), body(Void)), loc) } }
  | loc = pos kDo body = scopeExpr kWhile cond = exp kOd {
    fun(a) {
      distributeScope(
        body(Void),
        fun(loopBody) { assertVoid(a, DoWhile(loopBody, cond(Val)), loc) }
      )
    }
  }
  | loc = pos kFor init = scopeExpr s[","] cond = exp s[","] step = exp kDo body = scopeExpr kOd {
    fun(a) {
      var fullBody = Seq(body(Void), step(Void));
      var whilePart = While(cond(Val), fullBody);
      distributeScope(
        init(Void),
        fun(initPart) {
          assertVoid(a, Seq(initPart, whilePart), loc)
        }
      )
    }
  }
  | bracketed[scopeExpr]
);

var argParser = memo $ eta syntax(arg = exp { arg(Val) });

var elsePart = memo $ eta syntax(
  kElif cond = exp kThen body = scopeExpr elseTail = elsePart
  { fun(x) { If(cond(Val), body(x), elseTail(x)) } }
  | kElse body = scopeExpr kFi { body }
  | loc = pos kFi { fun(x) { assertVoid(x, Skip, loc) } }
);

var varDef = memo $ eta syntax(
  x = lident { [x, None] }
  | x = lident s["="] init = basic { [x, Some(init(Val))] }
);

var genericDef = memo $ eta syntax(
  s["var"] varDefs = list[varDef] s[";"] { Var(varDefs) }
  | s["fun"] funName = lident args = bracketed[list0(lident)] s["{"]
    body = scopeExpr s["}"] { Fun(funName, args, body(Weak)) }
);

var defenitions = memo $ eta syntax(
  headDef = genericDef tailDefs = defenitions { headDef:tailDefs }
  | headDef = genericDef { { headDef } }
);

var scopeExpr = memo $ eta syntax(
  defs = defenitions e = exp { fun(x) { expandScope(defs, e(x)) } }
  | e = exp { fun(x) { Scope({}, e(x)) } }
);

fun binaryOperation(op) {
  [
    syntax(pos -s[op]),
    fun(l, loc, r) {
      fun(x) {
        assertValue(x, Binop(op, l(Val), r(Val)), loc)
      }
    }
  ]
}


var basic = memo $ eta(
  expr(
    {
      [
        Right,
        {
          [
            syntax(pos -s[":="]),
            fun(l, loc, r) {
              fun(x) {
                assertValue(x, Assn(l(Ref), r(Val)), loc)
              }
            }
          ]
        }
      ],
      [Left, map(binaryOperation, { "!!" })],
      [Left, map(binaryOperation, { "&&" })],
      [Nona, map(binaryOperation, { "==", "!=", "<", ">", "<=", ">=" })],
      [Left, map(binaryOperation, { "+", "-" })],
      [Left, map(binaryOperation, { "*", "/", "%" })]
    },
    primary
  )
);

var exp = memo $ eta syntax(
  basic
  | left = basic s[";"] right = exp { fun(x) { Seq(left(Void), right(x)) } }
);

-- Public top-level parser
public parse = syntax(s=scopeExpr {s(Void)});
