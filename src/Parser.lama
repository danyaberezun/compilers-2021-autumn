-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;
import STM;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- AST environment
fun createEnv (id) {
  fun freshName () {
    [createEnv (id+1), sprintf ("_tmp%d", id)]
  }

  [freshName]
}

fun emptyEnv () {
  createEnv (0)
}

fun freshName (env) {
  env [0] ()
}

-- Attribute-processing functions

-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

fun wrapValue (v, loc) {
  fun (atr) {
    case atr of
      Val -> v
    | Weak -> v
    | Void -> v => fun (v) { Ignore (v) }
    | Ref -> error ("Expected reference, got a plain value " ++ string (v), loc)
    esac
  }
}

fun wrapVoid (v, loc) {
  fun (atr) {
    case atr of
      Void -> v
    | Weak -> v => fun (v) { Seq (v, Const (0)) }
    | Val -> error ("Expected Val, got Void", loc)
    | Ref -> error ("Expected Ref, got Void", loc)
    esac
  }
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [
    syntax (pos -s[op]),
    fun (l, loc, r) {
      wrapValue (
        chainST({l (Val), r (Val)}) => fun ({l, r}) {
          Binop (op, l, r)
        },
        loc
      )
    }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s (","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s (","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandVarDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Set (ident, value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  fun expandValDefs (defs, expr) {
    foldr (fun ([defs, expr], [ident, value]) {     
             [ident : defs, Seq (Ignore (Set (ident, value)), expr)]
           },
           [{}, expr],
           defs)
  }
  
  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Val (ds) ->
                 case expandValDefs (ds, expr) of
                   [ds, expr] -> [Val (ds) : defs, expr]
                 esac
             | Var (ds) ->             
                 case expandVarDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac  
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

-- Helper AST function: reifies pattern bindings into scope
-- definitions and assignments; takes an returns lists of
-- pattern-branch pairs
fun reifyPatternBindings (matched, brs) {
  map (
    fun ([pat, br]) {      
      fun collectBindings (path, p) {
        fun collectList (path, ps) {
          case
            foldl (fun ([acc, i], p) {
                     [collectBindings (i : path, p) : acc, i+1]                      
                   },
                   [{}, 0],
                   ps) of
            [acc, _] -> flatten (acc)
          esac            
        }
        
        case p of
          Sexp  (_, ps)   -> collectList (path, ps)
        | Array (ps)      -> collectList (path, ps)
        | Named (name, p) -> [name, path] : collectBindings (path, p)
        |  _              -> {}
        esac
      }

      case collectBindings ({}, pat) of
        {}       -> [pat, br]
      | bindings ->
           [pat,
             expandScope (
               {Val (map (
                      fun ([name, path]) {
                        [name, foldr (fun (p, i) {Elem (p, Const (i))}, Var (matched), path)]
                      },
                      bindings))},
               br
             )]
      esac
    },
    brs
  )
}

fun makeIf (cases, finalE) {
  fun (atr) {
    case cases of
      {} -> finalE (atr)
    | [cond, branch] : otherCases ->
      chainST ({cond (Val), branch (atr), makeIf (otherCases, finalE) (atr)}) =>
        fun ({cond, thenBranch, elseBranch}) {
          If (cond, thenBranch, elseBranch)
        }
    esac
  }
}

var primary = memo $ eta syntax (
  -- array constant
  loc=pos
  x=inbr[
    s ("["),
    list0 (syntax (e=exp { e (Val) })),
    s ("]")
  ] {
    wrapValue (chainST (x) => fun (x) {
      Array (x)
    }, loc)
  }

| -- string constant
  loc=pos
  x=strlit {
    wrapValue (returnST $ String (x), loc)
  }

| -- character literal
  loc=pos
  x=chrlit {
    wrapValue (returnST $ Const (x), loc)
  }

| -- decimal constant
  loc=pos
  x=decimal {
    wrapValue (returnST $ Const (stringInt (x)), loc)
  }

| -- an identifier or a function call
  loc=pos
  x=lident
  args=inbr[
    s ("("),
    list0 (syntax (e=exp {e (Val)})),
    s (")")
  ]? {
    case args of
      None -> -- variable reference
        fun (atr) {
          returnST $ case atr of
            Ref -> Ref (x)
          | Void -> Ignore (Var (x))
          | _ -> Var (x)
          esac
        }
    | Some (args) -> -- function call
        wrapValue (
          chainST (args) => fun (args) {
            Call (x, args)
          },
          loc
        )
    esac
  }

| -- S-expression
  loc=pos
  x=uident
  args=inbr[
    s ("("),
    list0 (syntax (e=exp {e (Val)})),
    s (")")
  ]? {
    var argList = case args of
      None -> {}
    | Some (args) -> args
    esac;
    wrapValue (chainST (args) => fun (args) {
      Sexp (x, args)
    }, loc)
  }

| -- skip
  loc=pos
  -kSkip {
    wrapVoid (returnST (Skip), loc)
  }

| -- surrounded with brackets
  inbr [
    s ("("),
    scopeExpr,
    s (")")
  ]

| -- if
  -kIf condE=exp
    -kThen thenE=scopeExpr
    elifBlocks=$(eta syntax (-kElif exp -kThen scopeExpr))*
    elseLoc=pos
    elseBlock=$(eta syntax (-kElse scopeExpr))?
  -kFi {
    var finalE = case elseBlock of
      Some (exp) -> exp
    | None -> wrapVoid (returnST (Skip), elseLoc)
    esac;
    makeIf ([condE, thenE] : elifBlocks, finalE)
  }

| -- while
  loc=pos
  -kWhile
    condE=exp
  kDo 
    bodyE=scopeExpr
  -kOd {
    wrapVoid (
      chainST ({condE (Val), bodyE (Void)}) =>
        fun ({cond, body}) {
          While (cond, body)
        },
      loc
    )
  }

| -- do-while
  loc=pos
  -kDo
    bodyE=scopeExpr 
  -kWhile 
    condE=exp
  kOd {
    wrapVoid (
      chainST ({bodyE (Void), condE (Val)}) =>
        fun ({body, cond}) {
          case body of
            Scope (defs, bodyE) ->
              Scope (defs, DoWhile (bodyE, cond))
          | bodyE ->
              DoWhile (bodyE, cond)
          esac
        },
      loc
    )
  }

| -- for
  loc=pos
  -kFor
    initE=scopeExpr
    s[","]
    condE=exp
    s[","]
    stepE=exp
  -kDo
    bodyE=scopeExpr
  -kOd {
    wrapVoid (
      chainST ({initE (Void), condE (Val), bodyE (Void), stepE (Void)}) =>
        fun ({init, cond, body, step}) {
          var loop = While (
            cond,
            Seq (
              body,
              step
            )
          );
          case init of 
            Scope (initDefs, initBody) ->
              Scope (initDefs, Seq (initBody, loop))
          | initE -> Seq (initE, loop)
          esac
        },
      loc
    )
  }
);
   
var basic = memo $ eta (
  expr (
    {
      [Right, {
          [
            s (":="),
            fun (l, loc, r) {
              wrapValue (
                chainST ({l (Ref), r (Val)}) => fun ({l, r}) {
                  Assn (l, r)
                },
                loc
              )
            }
          ]
        }
      ],
      [Left, map (binop, {"!!"})],
      [Left, map (binop, {"&&"})],
      [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
      [Left, map (binop, {"+", "-"})],
      [Left, map (binop, {"*", "/", "%"})]
    },
    postfix
  )
);
  
var postfix = memo $ eta syntax (
  loc=pos
  e=primary
  ps=(i=inbr [s ("["), exp, s ("]")] {Index (i (Val))})* {
    fun (atr) {
      foldl (
        fun (e, p) {
          case p of
            Index (i) -> fun (atr) {
             case atr of
               Ref -> e (Val) =>> fun (e) {
                   i => fun (i) {
                     ElemRef (e, i)
                   }
                 } 
             | _ -> 
               var vl = e (Val) =>> fun (e) {
                 i => fun (i) {
                   Elem (e, i)
                 }
               };
               case atr of
                 Void -> Ignore (vl)
                | _ -> vl
               esac
             esac
           }
          esac
        },
        e,
        ps
      ) (atr)
    }
  }
);
  
var scopeExpr  = memo $ eta syntax (
  ds=definition*
  e=exp? {
    fun (atr) {
      fun (e) {
        case ds of
          {} -> e
        | _  -> chainST (ds) =>> fun (ds) {
              e => fun (e) {
                expandScope (ds, e)
              }
            }
        esac
      }
      (case e of 
        Some (e) -> e (atr)
      | _        -> returnST $ Skip
      esac)
    }
  }                                                                  
);
  
var definition = memo $ eta syntax (
  kVar
  ds=list[syntax (x=lident e=(-s["="] basic)? {
    case e of
      None -> returnST $ [x, None]
    | Some (e) ->
        e (Val) => fun (e) {[x, Some (e)]}
    esac})] s[";"] {
    chainST (ds) => fun (ds) {Var (ds)}
  } |
  kVal ds=list[syntax (x=lident s["="] e=basic {e (Val) => fun (e) {[x, e]}})] s[";"] {
    chainST (ds) => fun (ds) {Val (ds)}
  } |  
  kFun name=lident args=inbr[s("("), list0 (lident), s(")")] body=inbr[s("{"), scopeExpr, s("}")] {
    body (Weak) => fun (body) {
      Fun (name, args, body)
    }
  }
);
  
var exp = memo $ eta syntax (
    basic
  | s1=basic s[";"] s2=exp {
     fun (a) {
       s1 (Void) =>> fun (s1) {
       s2 (a)    =>  fun (s2) {
         Seq (s1, s2)
       }}
     }
   }
  );

-- Public top-level parser
public parse = syntax (
  s=scopeExpr {
    s (Void) (emptyEnv ()) [1]
  }
);
