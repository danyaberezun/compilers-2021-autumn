-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inparens(p) {
  inbr(s("("), p, s(")"))
}

fun binop(l, op, r) {Binop (op, l, r)}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inparens[exp]
);

var exp = memo $ eta expr({
  [Left, {
    [s ("!!"), binop]
  }],
  [Left, {
    [s ("&&"), binop]
  }],
  [Nona, {
    [s ("=="), binop],
    [s ("!="), binop],
    [s ("<" ), binop],
    [s ("<="), binop],
    [s (">" ), binop],
    [s (">="), binop]
  }],
  [Left, {
      [s ("+"), binop],
      [s ("-"), binop]
  }],
  [Left, {
      [s ("*") , binop],
      [s ("/") , binop],
      [s ("%") , binop]
  }]
}, primary);

var stmt_ = memo $ eta syntax (
  kRead  x=inparens[lident] {Read(x)}    |
  kWrite x=inparens[exp]    {Write(x)}   |
  kSkip                     {Skip}       |
  x=lident s[":="] e=exp    {Assn(x, e)} |
  ifStmt |
  kWhile e=exp kDo s=stmt kOd {While(e, s)} |
  kDo s=stmt kWhile e=exp kOd {DoWhile(s, e)} |
  kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd {Seq(s1, While(e, Seq(s3, s2)))}
);

var ifStmt = memo $ eta syntax (
  kIf cond=exp kThen s=stmt cont=ifStmt_ kFi {If(cond, s, cont)}
);

var ifStmt_ = memo $ eta syntax (
  kElif cond=exp kThen s=stmt cont=ifStmt_ {If(cond, s, cont)} |
  kElse s=stmt {s} |
  empty {Skip}
);

var stmt = memo $ eta syntax(h=stmt_ t=(-s[";"] stmt_)* { foldr(fun (acc, x) { Seq(x, acc) }, Skip, h:t) });

-- Public top-level parser
public parse = stmt;
