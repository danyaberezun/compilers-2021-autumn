-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

var primary  = memo $ eta syntax (
                                  -- decimal constant
                                  loc=pos x=decimal                                 {fun (a) {assertValue (a, Const (stringInt (x)), loc)}}     |

                                  -- identifier
                                  x=lident                                          {fun (a) {
                                                                                       case a of
                                                                                         Ref  -> Ref (x)
                                                                                       | Void -> Ignore (Var (x))
                                                                                       | _    -> Var (x)
                                                                                       esac
                                                                                    }} |
                                  $(failure ("the rest of primary parsing in not implemented\n"))),
    basic    = memo $ eta (expr ({[Right, {[s (":="),
                                            fun (l, loc, r) {
                                              fun (a) {assertValue (a, Assn (l (Ref), r (Val)), loc)}
                                            }]}],
                                  [Left , map (binop, {"!!"})],
                                  [Left , map (binop, {"&&"})],
                                  [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
                                  [Left , map (binop, {"+", "-"})],
                                  [Left , map (binop, {"*", "/", "%"})]
                                 },
                                 primary)),
    exp      = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});

(*
fun opStr (op) {
  syntax (s[op] {op})
}

var binop0 = syntax (opStr["!!"]);

var binop1 = syntax (opStr["&&"]);

var binop2 = syntax (
  opStr[">"] |
  opStr["<"] |
  opStr[">="] |
  opStr["<="] |
  opStr["=="] |
  opStr["!="]
);

var binop3 = syntax (
  opStr["+"] |
  opStr["-"]
);

var binop4 = syntax (
  opStr["*"] |
  opStr["/"] |
  opStr["%"]
);

fun opExpr (binop, lelem, relem) {
  syntax (l=lelem op=binop r=relem {Binop (op, l, r)})
}

var sum4 = memo $ eta syntax ( opExpr4 | primary );

var opExpr4 = memo $ eta syntax (
  opExpr[binop4, sum4, primary]
);

var sum3 = memo $ eta syntax ( opExpr3 | opExpr4 | primary );

var opExpr3 = memo $ eta syntax (
  opExpr[binop3, sum3, sum4]
);

var sum2 = memo $ eta syntax ( opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr2 = memo $ eta syntax (
  opExpr[binop2, sum2, sum3]
);

var sum1 = memo $ eta syntax ( opExpr1 | opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr1 = memo $ eta syntax (
  opExpr[binop1, sum1, sum2]
);

var sum0 = memo $ eta syntax ( opExpr0 | opExpr1 | opExpr2 | opExpr3 | opExpr4 | primary );

var opExpr0 = memo $ eta syntax (
  opExpr[binop0, sum0, sum1]
);

-- Primary expression
(*var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta (failure ("expression parsing not implemented\n"));*)

var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
  exp = memo $ eta syntax (
    sum0
  );

var readPat  = memo $ eta syntax ( kRead x=inbr[s("("), lident, s(")")] {Read (x)} ),
    writePat = memo $ eta syntax ( kWrite x=inbr[s("("), exp, s(")")] {Write (x)} ),
    assnPat  = memo $ eta syntax ( l=lident s[":="] r=exp {Assn (l, r)} ),
    skipPat = memo $ eta syntax ( kSkip {Skip} ),
    whilePat = memo $ eta syntax ( kWhile x=exp kDo y=stmt kOd {While (x, y)} ),
    elifPat = syntax ( kElif xi=exp kThen yi=stmt { [xi, yi] } ),
    ifPat = memo $ eta syntax ( 
      kIf x1=exp kThen y1=stmt a=(elifPat)* b=(kElse yLast=stmt { yLast })? kFi {
        var start =
          case b of
            Some (y) -> If (x1, y1, y)
          | _ -> If (x1, y1, Skip)
          esac;
        foldl (
          fun (acc, x) {
            case acc of
              If (e, s1, s2) -> If (e, s1, If (x[0], x[1], s2))
            esac
          }
        , start, a)
      }
    ),
    forPat = memo $ eta syntax (
      kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd {
        Seq (
          s1,
          While (e, Seq (s3, s2))
        )
      }
    ),
    doWhilePat = memo $ eta syntax ( kDo y=stmt kWhile x=exp kOd {DoWhile (y, x)} );

var stmtFirst = memo $ eta syntax (whilePat | forPat | ifPat | doWhilePat | assnPat | readPat | writePat | skipPat);

var stmt = memo $ eta syntax (
    l=stmtFirst s[";"] r=stmt {Seq (l, r)} | stmtFirst
);

-- Public top-level parser
public parse = stmt;
*)
