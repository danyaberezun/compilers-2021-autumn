-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const(stringInt(x)) } |
  x=lident { Var(x) }                                              |
  inbr[s("("), exp, s(")")]
),
    exp = memo $ eta (expr({
    [Left, map(binOp, { "!!", "&&" })],
    [Nona, map(binOp, { "<", ">", "<=", ">=", "==", "!=" })],
    [Left, map(binOp, { "+", "-" })],
    [Left, map(binOp, { "/", "*", "%" })]
  }, primary)
  );

fun binOp(op) {
  [s(op), fun (l, op, r) { Binop(op, l, r) }]
}

var elsePart = memo $ eta syntax (
  empty { Skip }
  | kElse s=parse { s }
  | kElif e=exp kThen s1=parse s2=elsePart { If(e, s1, s2) }
);

var stmt = memo $ eta syntax (
  v=lident s[":="] e=exp { Assn(v, e) }
  | x=stmt s[";"] y=stmt end { Seq(x, y) }
  | kSkip { Skip }
  | kRead v=inbr[s("("), lident, s(")")] { Read(v) }
  | kWrite r=inbr[s("("), exp, s(")")] { Write(r) }
  | kWhile e=exp kDo s=parse kOd { While(e, s) }
  | kDo s=parse kWhile e=exp kOd { DoWhile(s, e) }
  | kFor vars=parse s[","] cond=exp s[","] afterAll=parse kDo body=parse kOd { Seq(vars, While(cond, Seq(body, afterAll))) }
  | kIf e=exp kThen s1=parse s2=elsePart kFi { If(e, s1, s2) }
);

-- Public top-level parser
public parse = memo $ eta syntax ( stmt | line=stmt s[";"] tail=parse { Seq(line, tail) } );