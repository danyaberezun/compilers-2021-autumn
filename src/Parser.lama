-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

-- Checks if a void epxression can be used in the context described by
-- the attribute "atr".
fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | Weak -> Seq (v, Const (0))
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- VDefn =
--   | VDefnEmpty (x)
--   | VDefnAssn (x, e)
--
-- RawProgram =
--   | Const (n)
--   | Var (x)
--   | Skip
--   | Scoped (e)
--   | If (c, t, {[c, t]}, f)
--   | Call (f, {a})
--   | Read (e)
--   | Write (e)
--   | Binop (l, {[op, r]})
--   | While (c, a)
--   | DoWhile (a, c)
--   | For (i, c, f, a)
--   | Seq ({e})
--   | VDefn ({d})
--   | FunDefn (f, {x}, b)

var
  pConst =
    memo $ eta syntax ( n=decimal { Const (stringInt (n)) } ),
  pVar =
    memo $ eta syntax ( x=lident { Var (x) } ),
  pSkip =
    memo $ eta syntax ( kSkip { Skip } ),
  pScoped =
    memo $ eta syntax ( s=inbr [s("("), pProgram, s(")")] { Scoped (s) } ),
  pElif =
    memo $ eta syntax ( -kElif e=pProgram -kThen a=pProgram { [e, a] } ),
  pIf =
    memo $ eta syntax ( -kIf e=pProgram -kThen t=pProgram es=pElif* -kElse f=pProgram -kFi { If (e, t, es, f) }
                      | -kIf e=pProgram -kThen t=pProgram es=pElif* -kFi { If (e, t, es, Skip) } ),
  pRead =
    memo $ eta syntax ( -kRead x=inbr [s("("), pProgram, s(")")] { Read (x) } ),
  pWrite =
    memo $ eta syntax ( -kWrite x=inbr [s("("), pProgram, s(")")] { Write (x) } ),
  pCall =
    memo $ eta syntax ( f=lident xs=inbr [s("("), list0 (pProgram), s(")")] { Call (f, xs) } ),
  pBinopArg =
    memo $ pConst | pVar | pScoped | pIf | pCall,
  pOp =
    memo $ eta syntax ( op=kBinop arg=pBinopArg { [op, arg] } ),
  pBinop =
    memo $ eta syntax ( l=pBinopArg ops=pOp+ { Binop (l, ops) } ),
  pWhile =
    memo $ eta syntax ( -kWhile e=pProgram -kDo a=pProgram -kOd { While (e, a) } ),
  pDoWhile =
    memo $ eta syntax ( -kDo a=pProgram -kWhile e=pProgram -kOd { DoWhile (a, e) } ),
  pFor =
    memo $ eta syntax ( -kFor i=pProgram -s[","] c=pProgram -s[","] f=pProgram -kDo a=pProgram -kOd
                        { For (i, c, f, a) } ),
  pVDefnEmpty =
    memo $ eta syntax ( x=lident { VDefnEmpty (x) } ),
  pAssnExpr =
    memo $ pBinop | pBinopArg,
  pVDefnAssn =
    memo $ eta syntax ( x=lident s["="] e=pAssnExpr { VDefnAssn (x, e) } ),
  pVDefnSingle =
    memo $ pVDefnEmpty | pVDefnAssn,
  pVDefn =
    memo $ eta syntax ( -kVar xs=list[pVDefnSingle] { VDefn (xs) } ),
  pFunDefn =
    memo $ eta syntax ( -kFun f=lident args=inbr[s("("), list0 (lident), s(")")] -s["{"] b=pProgram -s["}"]
                        { FunDefn (f, args, b) } ),
  pSeqSC =
    memo $ pConst | pVar | pSkip | pScoped | pIf | pRead | pWrite | pCall | pBinop | pWhile | pDoWhile | pFor | pVDefn,
  pSeqNoSC =
    pFunDefn,
  pSeqStep =
    memo $ eta syntax ( pSeqSC -s[";"] | pSeqNoSC ),
  pSeqEnd =
    memo $ eta syntax ( pSeqSC | pSeqNoSC ),
  pSeq =
    memo $ eta syntax ( fs=pSeqStep* ls=pSeqEnd { Seq (fs +++ {ls}) } ),
  pProgram = pSeq,
  pFullProgram = pSeq |> bypass (end);
 

fun codegen (p) {
  fun immediateDefns (p) {
    case p of
      Seq (es) ->
        fun f (acc@[b, ds, rs], c) {
          case [b, c] of
            [True, _]              -> [b,    ds,     c : rs]
          | [_, VDefn (_)]         -> [b,    c : ds, rs]
          | [_, FunDefn (_, _, _)] -> [b,    c : ds, rs]
          | _                      -> [True, ds,     c : rs]
          esac
        }
        case foldl (f, [False, {}, {}], es) of
          [_, ds, {}] -> [ds.reverse, Skip]
        | [_, ds, rs] -> [ds.reverse, Seq (rs.reverse)]
        esac
    | VDefn (_) -> [{p}, Skip]
    | FunDefn (_, _, _) -> [{p}, Skip]
    | a -> [{}, a]
    esac
  }

  fun expandScopes (p) {
    case p of
      Scoped (e) ->
        Scoped (expandScopes (e))
    | If (c, t, es, f) ->
        If
          ( expandScopes (c)
          , expandScopes (t)
          , map (fun ([c, t]) { [expandScopes (c), expandScopes (t)] }, es)
          , expandScopes (f)
          )
    | Call (f, as) ->
        Call (f, map (expandScopes, as))
    | Read (e) ->
        Read (expandScopes (e))
    | Write (e) ->
        Write (expandScopes (e))
    | Binop (l, ops) ->
        Binop
          ( expandScopes (l)
          , map (fun ([op, r]) { [op, expandScopes (r)] }, ops)
          )
    | While (c, a) ->
        While (expandScopes (c), expandScopes (a))
    | DoWhile (a, c) ->
        case immediateDefns (a) of
          [ds, rs] -> Seq (ds +++ {DoWhile (expandScopes (rs), expandScopes (c))})
        esac
    | For (i, c, f, a) ->
        case immediateDefns (i) of
          [ds, rs] ->
            Seq
              (ds +++
               { For
                  ( expandScopes (rs)
                  , expandScopes (c)
                  , expandScopes (f)
                  , expandScopes (a)
                  )
               })
        esac
    | Seq (es) ->
        fun f (acc, e) {
          case expandScopes (e) of
            Seq (ies) -> reverse (ies) +++ acc
          | ie        -> ie : acc
          esac
        }
        Seq (foldl (f, {}, es).reverse)
    | VDefn (ds) ->
        fun f (d) {
          case d of
            VDefnEmpty (x) -> VDefnEmpty (x)
          | VDefnAssn (x, e) -> VDefnAssn (x, expandScopes (e))
          esac
        }
        VDefn (map (f, ds))
    | FunDefn (f, xs, b) ->
        FunDefn (f, xs, expandScopes (b))
    | a -> a
    esac
  }

  fun mkSeq (e) {
    case e of
      Seq (e) -> Seq (e)
    | a -> Seq ({a})
    esac
  }

  fun makeScopes (p) {
    case p of
      Seq (es) ->
        fun f ([ds, rs], e) {
          case e of
            Scoped (e) ->
              [ds, makeScopes (mkSeq (e)) : rs]
          | If (c, t, es, f) ->
              [ ds
              , If
                  ( makeScopes (mkSeq (c))
                  , makeScopes (mkSeq (t))
                  , map (fun ([c, t]) { [makeScopes (mkSeq (c)), makeScopes (mkSeq (t))] }, es)
                  , makeScopes (mkSeq (f))
                  )
                : rs
              ]
          | Call (e, as) ->
              [ds, Call (e, map (fun (a) { makeScopes (mkSeq (a)) }, as)) : rs]
          | Read (e) ->
              [ds, Read (makeScopes (mkSeq (e))) : rs]
          | Write (e) ->
              [ds, Write (makeScopes (mkSeq (e))) : rs]
          | Binop (l, as) ->
              [ ds
              , Binop
                  ( makeScopes (mkSeq (l))
                  , map (fun ([op, r]) { [op, makeScopes (mkSeq (r))] }, as)
                  )
                : rs
              ]
          | While (c, a) ->
              [ds, While (makeScopes (mkSeq (c)), makeScopes (mkSeq (a))) : rs]
          | DoWhile (a, c) ->
              [ds, DoWhile (makeScopes (mkSeq (a)), makeScopes (mkSeq (c))) : rs]
          | For (i, c, f, a) ->
              [ds,
                For
                  ( makeScopes (mkSeq (i))
                  , makeScopes (mkSeq (c))
                  , makeScopes (mkSeq (f))
                  , makeScopes (mkSeq (a))
                  )
                : rs
              ]
          | Seq (_) ->
              failure ("seq in seq (likely there's a bug in expandScopes)\n")
          | VDefn (defns) ->
              fun f ([ds, as], p) {
                case p of
                  VDefnEmpty (x) -> [VDefn (x) : ds, as]
                | VDefnAssn (x, e) -> [VDefn (x) : ds, Binop (Var (x), {[":=", makeScopes (mkSeq (e))]}) : as]
                esac
              }
              case foldl (f, [{}, {}], defns) of
                [nds, as] -> [nds +++ ds, as +++ rs]
              esac
          | FunDefn (f, xs, b) ->
              [FunDefn (f, xs, makeScopes (mkSeq (b))) : ds, rs]
          | a -> [ds, a : rs]
          esac
        }

        case foldl (f, [{}, {}], es) of
          [ds, es] -> Scope (ds.reverse, Seq (es.reverse))
        esac
    | Skip -> Skip
    | _ -> failure ("ill-formed program %s", p.string)
    esac
  }

  fun binopToExpr (b) {
    fun mkOp (op, l, r) {
      case op of
        ":=" -> Assn(l, r)
      | op   -> Binop (op, l, r)
      esac
    }

    fun elem (e, es) {
      case es of
        {}  -> 0
      | h:t -> (compare(e, h) == 0) !! elem (e, t)
      esac
    }

    fun leftAssoc (l, rs, ops, t) {
      case rs of
        {} -> rec (l, t)
      | [op, r]:rs ->
          if elem (op, ops)
          then mkOp (op, rec (l, t), leftAssoc (r, rs, ops, t))
          else
            case l of
              Binop (l, lrs) -> leftAssoc (Binop (l, lrs +++ {[op, r]}), rs, ops, t)
            | l              -> leftAssoc (Binop (l, {[op, r]}), rs, ops, t)
            esac
          fi
      esac
    }

    fun rightAssoc (l, rs, ops, t) {
      fun split (l, ls, rs, ops) {
        case rs of
          {} -> None
        | [op, r]:rs ->
            case split (l, ls +++ {[op, r]}, rs, ops) of
              Some (l, ls, rs) -> Some (l, ls, rs)
            | None ->
              if elem (op, ops)
              then Some (l, ls, [op,r]:rs)
              else None
              fi
            esac
        esac
      }

      case split (l, {}, rs, ops) of
        Some (l, ls, [op, r]:rs) -> mkOp (op, rightAssoc (l, ls, ops, t), rec (Binop (r, rs), t))
      | None -> rec (Binop (l, rs), t)
      esac
    }

    fun rec (b, ops) {
      case b of
        Binop (l, rs) ->
          case ops of
            {} ->
              case rs of
                {}         -> l
              | [op, r]:rs -> failure ("unknown binop %s", op)
              esac
          | [Left, ops]:t  -> leftAssoc (l, rs, ops, t)
          | [Right, ops]:t -> rightAssoc (l, rs, ops, t)
          esac
      | a -> a
      esac
    }

    var ops =
      {[Left,  {":="}],
       [Right, {"&&", "!!"}],
       [Right, {"<", ">", "<=", ">=", "==", "!="}],
       [Right, {"+", "-"}],
       [Right, {"*", "/", "%"}]};

    rec (b, ops)    
  }

  fun toExpr (p) {
    fun finalizeBinops (e) {
      case e of
        Assn (l, r)      -> Assn (finalizeBinops (l), finalizeBinops (r))
      | Binop (op, l, r) -> Binop (op, finalizeBinops (l), finalizeBinops (r))
      | e                -> toExpr (e)
      esac
    }

    case p of
      Const (n) ->
        Const (n)
    | Var (x) ->
        Var (x)
    | Skip ->
        Skip
    | Scope (ds, e) ->
        fun f (d) {
          case d of
            VDefn (x) -> VDefn (x)
          | FunDefn (f, args, b) -> FunDefn (f, args, toExpr (b))
          esac
        }
        Scope (map (f, ds), toExpr (e))
    | If (c, t, es, f) ->
        fun rec (es) {
          case es of
            {}          -> toExpr (f)
          | [c, t] : es -> If (toExpr (c), toExpr (t), rec (es))
          esac
        }
        If (toExpr (c), toExpr (t), rec (es))
    | Call (f, args) ->
        Call (f, map (toExpr, args))
    | Read (e) ->
        Read (toExpr (e))
    | Write (e) ->
        Write (toExpr (e))
    | Binop (l, rs) ->
        finalizeBinops (binopToExpr (Binop (l, rs)))
    | While (c, a) ->
        While (toExpr (c), toExpr (a))
    | DoWhile (a, c) ->
        DoWhile (toExpr (a), toExpr (c))
    | For (i, c, f, a) ->
        Seq (toExpr (i), While (toExpr (c), Seq (toExpr (a), toExpr (f))))
    | Seq (es) ->
        case es.reverse of
          {}   -> Skip
        | e:es -> foldl (fun (a, b) { Seq (toExpr (b), a) }, toExpr (e), es)
        esac
    esac
  }

  var pExpanded = expandScopes (p);
  var pScoped = makeScopes (pExpanded);
  var pExpr = toExpr (pScoped);

  pExpr
}

fun typecheck (p) {
  fun workAll (exps, typ) {
    case exps of
      {} -> Succ ({})
    | e:exps ->
        case work (e, typ) of
          Succ (e) ->
            case workAll (exps, typ) of
              Succ (exps) -> Succ (e : exps)
            | Fail        -> Fail
            esac
        | Fail -> Fail
        esac
    esac
  }

  -- как же иногда хочется простого человеческого foldM
  fun workDefs (ds) {
    fun workDef (d) {
      case d of
        VDefn (x) -> Succ (VDefn (x))
      | FunDefn (f, args, body) ->
          case work (body, Weak) of
            Succ (body) -> Succ (FunDefn (f, args, body))
          | Fail        -> Fail
          esac
      esac
    }

    -- printf("%s\n\n", ds.string);
    case ds of
      {} -> Succ ({})
    | d:ds ->
        case workDef (d) of
          Succ (d) ->
            case workDefs (ds) of
              Succ (ds) -> Succ (d : ds)
            | Fail      -> Fail
            esac
        | Fail -> Fail
        esac
    esac
  }

  fun work (p, typ) {
     case typ of
       Void ->
         case p of
           Var (x) ->
             Succ (Ignore (Var (x)))
         | Const (n) ->
             Succ (Ignore (Const (n)))
         | Binop (op, lhs, rhs) ->
             case {work (lhs, Val), work (rhs, Val)} of
               {Succ (lhs), Succ (rhs)} -> Succ (Ignore (Binop (op, lhs, rhs)))
             | _                        -> Fail
             esac
         | Assn (x, e) ->
             case {work (x, Ref), work (e, Val)} of
               {Succ (x), Succ (e)} -> Succ (Ignore (Assn (x, e)))
             | _                    -> Fail
             esac
         | Read (x) ->
             case work (x, Ref) of
               Succ (x) -> Succ (Read (x))
             | _        -> Fail
             esac
         | Skip -> Succ (Skip)
         | Write (e) ->
             case work (e, Val) of
               Succ (e) -> Succ (Write (e))
             | _        -> Fail
             esac
         | Call (f, args) ->
             case workAll (args, Val) of
               Succ (args) -> Succ (Ignore (Call (f, args)))
             | _           -> Fail
             esac
         | Seq (lhs, rhs) ->
             case {work (lhs, Void), work (rhs, Void)} of
               {Succ (lhs), Succ (rhs)} -> Succ (Seq (lhs, rhs))
             | _                        -> Fail
             esac
         | If (e, t, f) ->
             case {work (e, Val), work (t, Void), work (f, Void)} of
               {Succ (e), Succ (t), Succ (f)} -> Succ (If (e, t, f))
             | _                              -> Fail
             esac
         | While (e, s) ->
             case {work (e, Val), work (s, Void)} of
               {Succ (e), Succ (s)} -> Succ (While (e, s))
             | _                    -> Fail
             esac
         | DoWhile (s, e) ->
             case {work (s, Void), work (e, Val)} of
               {Succ (s), Succ (e)} -> Succ (DoWhile (s, e))
             | _                    -> Fail
             esac
         | Scope ({}, e) ->
             work (e, Void)
         | Scope (ds, e) ->
             case {workDefs (ds), work (e, Void)} of
               {Succ (ds), Succ (p)} -> Succ (Scope (ds, p))
             | _                     -> Fail
             esac
         | _ -> Fail
         esac
     | Ref ->
         case p of
           Var (x) ->
             Succ (Ref (Var (x)))
         | Seq (lhs, rhs) ->
             case {work (lhs, Void), work (rhs, Ref)} of
               {Succ (l), Succ (r)} -> Succ (Seq (l, r))
             | _                    -> Fail
             esac
         | If (e, t, f) ->
             case {work (e, Val), work (t, Ref), work (f, Ref)} of
               {Succ (e), Succ (t), Succ (f)} -> Succ (If (e, t, f))
             | a                              -> Fail
             esac
         | Scope ({}, e) ->
             work (e, Ref)
         | Scope (ds, e) ->
             case {workDefs (ds), work (e, Ref)} of
               {Succ (ds), Succ (p)} -> Succ (Scope (ds, p))
             | _                     -> Fail
             esac
         | _ -> Fail
         esac
     | Val ->
         case p of
           Var (x) ->
             Succ (Var (x))
         | Const (n) ->
             Succ (Const (n))
         | Binop (op, lhs, rhs) ->
             case {work (lhs, Val), work (rhs, Val)} of
               {Succ (lhs), Succ (rhs)} -> Succ (Binop (op, lhs, rhs))
             | _                        -> Fail
             esac
         | Assn (x, e) ->
             case {work (x, Ref), work (e, Val)} of
               {Succ (x), Succ (e)} -> Succ (Assn (x, e))
             | _                    -> Fail
             esac
         | Seq (lhs, rhs) ->
             case {work (lhs, Void), work (rhs, Val)} of
               {Succ (lhs), Succ (rhs)} -> Succ (Seq (lhs, rhs))
             | _                        -> Fail
             esac
         | If (e, t, f) ->
             case {work (e, Val), work (t, Val), work (f, Val)} of
               {Succ (e), Succ (t), Succ (f)} -> Succ (If (e, t, f))
             | _                              -> Fail
             esac
         | Call (f, args) ->
             case workAll (args, Val) of
               Succ (args) -> Succ (Call (f, args))
             | Fail        -> Fail
             esac
         | Scope ({}, e) ->
             work (e, Val)
         | Scope (ds, e) ->
             case {workDefs (ds), work (e, Val)} of
               {Succ (ds), Succ (p)} -> Succ (Scope (ds, p))
             | _                     -> Fail
             esac
         | _ -> Fail
         esac
     | Weak ->
         case work (p, Val) of
           Succ (p) -> Succ (p)
         | Fail     ->
             case work (p, Void) of
               Succ (p) -> Succ (Seq (p, Const (0)))
             | Fail     -> Fail
             esac
         esac
     esac
  }

  var res =
    case p of
      Scope (ds, e) ->
        case {workDefs (ds), work (e, Weak)} of
          {Succ (ds), Succ (e)} -> Succ (Scope (ds, e))
        esac
    esac;
  -- printf ("%s\n", p.string);
  -- printf ("%s\n", res.string);

  fun (k) {
    fun (s) {
      k (case res of
           Succ (p) -> Succ (p, s)
         | Fail     -> Fail ("typecheck failed", 0, 0)
         esac)
    }
  }
}

-- Public top-level parser
public parse = (pFullProgram @ codegen) |> typecheck;
