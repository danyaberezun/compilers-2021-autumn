-- Parser
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(l, p, r) {
  syntax(-l p -r)
}

fun binaryOperation(op) {
  [s(op), fun(l, _, r) { Binop(op, l ,r) }]
}

-- Primary expression
var primary = memo $ eta(
  decimal @ fun(x) { Const(stringInt(x)) }
  | lident @ fun(x) { Var(x) }
  | inbr(s("("), expression, s(")"))
);

var expression = memo $ eta(
  expr(
    {
      [Left, { binaryOperation("!!") }],
      [Left, { binaryOperation("&&") }],
      [Nona, map(binaryOperation, { "==", "!=", ">", "<", ">=", "<=" })],
      [Left, map(binaryOperation, { "+", "-" })],
      [Left, map(binaryOperation, { "*", "/", "%" })]
    },
    primary
  )
);

var ifStatement = memo $ eta syntax(
    empty { Skip }
    | kElse elseBody = statement { elseBody }
    | kElif condition = expression kThen s1 = statement elseBody = ifStatement
      { If(condition, s1, elseBody) }
  );

var separateStatement = memo $ eta syntax(
  kSkip { Skip }
  | kRead variable = inbr [s("("), lident, s(")")] { Read(variable) }
  | kWrite value = inbr [s("("), expression, s(")")] { Write(value) }
  | variable = lident s [":="] value = expression { Assn(variable, value) }
  | kWhile condition = expression kDo body = statement kOd { While(condition, body) }
  | kDo body = statement kWhile condition = expression kOd { DoWhile(body, condition) }
  | kFor initialization = statement s[","] condition = expression s[","]
    increment = statement kDo body = statement kOd
    { Seq(initialization, While(condition, Seq(body, increment))) }
  | kIf condition = expression kThen thenBody = statement elseBody = ifStatement kFi
    { If(condition, thenBody, elseBody) }
);


var statement = memo $ eta syntax(
  separateStatement
  | left = separateStatement s [";"] right = statement { Seq(left, right) }
);

-- Public top-level parser
public parse = statement;
