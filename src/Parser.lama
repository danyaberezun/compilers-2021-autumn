-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var getBinopTree = fun (l, op, r) {Binop (op, l, r)};

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),

    exp = memo $ eta expr({[Left, {[s ("!!"), getBinopTree]}], [Left, {[s ("&&"), getBinopTree]}],
                           [Nona, {[s ("<"),  getBinopTree], [s ("<="), getBinopTree],
                                   [s ("=="), getBinopTree], [s ("!="), getBinopTree],
                                   [s (">"),  getBinopTree], [s (">="), getBinopTree]
                                  }],
                           [Left, {[s ("+"), getBinopTree], [s ("-"), getBinopTree]}],
                           [Left, {[s ("*"), getBinopTree], [s ("/"), getBinopTree], [s ("%"), getBinopTree]}]
                           }, primary),

    stmt = memo $ eta syntax (x=lident -s[":="] e=exp                 { Assn  (x, e) }  |
                              -kRead x=inbr[s ("("), lident, s (")")] { Read  (x) }     |
                              -kWrite e=inbr[s ("("), exp, s (")")]   { Write (e) }     |
                              -kSkip                                  { Skip }          |
                               conditionStmt);

var conditionStmt = memo $ eta syntax (
    -kWhile cond=exp      -kDo     body=seqStmt -kOd                                 { While   (cond, body) }              |
    -kDo    body=seqStmt  -kWhile  cond=exp     -kOd                                 { DoWhile (body, cond) }              |
    -kFor   init=seqStmt  -s[","]  cond=exp -s[","] step=stmt -kDo body=seqStmt -kOd { Seq (init, While (cond, Seq (body, step))) } |
    -kIf    cond=exp      -kThen   trueBody=seqStmt elsePart=elsePart -kFi           { If (cond, trueBody, elsePart) }
);

var elsePart = memo $ eta syntax (
    elifs=elifPart* lastElse=(-kElse seqStmt)? {
        case lastElse of
          None -> buildIf (elifs, Skip)
        | Some (lastElse) -> buildIf (elifs, lastElse)
        esac
    }
);

var elifPart = memo $ eta syntax (-kElif cond=exp -kThen body=seqStmt { ElsePart (cond, body) });

-- Build If statement
fun buildIf (ls, postfixStmt) {
  foldr (fun (acc, ElsePart (e, stmt)) {If (e, stmt, acc)}, postfixStmt, ls)
}

-- Build parse tree based on list of statements
fun buildParseTree (ls) {
  case ls of
                  -- todo zhvkgj: replace on building AVL Tree to improve performance
    st1 : st2 : tl -> foldl (fun (seq, el) {Seq (seq, el)}, Seq (st1, st2), tl)
  | st1 : {}     -> st1
  | _          -> {}
  esac
}

var seqStmt = memo $ eta syntax (ls=list0By[stmt, s(";")] {buildParseTree (ls)});

-- Public top-level parser
public parse = seqStmt;
