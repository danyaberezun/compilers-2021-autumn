-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Utility;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Binary operators
fun procBinops (binops) {
  fun makeBinop (l, op, r) {
    Binop (op, l, r)
  }

  fun procBinop (op) {
    [s (op), makeBinop]
  }

  fun procBinopGroup ([assoc, ops]) {
    [assoc, map (procBinop, ops)]
  }

  map (procBinopGroup, binops)
}

var binops = procBinops ({
  [Right, {"!!"}],
  [Right, {"&&"}],
  [Nona,  {"==", "!=", "<", "<=", ">", ">="}],
  [Left,  {"+", "-"}],
  [Left,  {"*", "/", "%"}]
});

-- Parens utility parser
var lParens = memo $ eta (s ("("));
var rParens = memo $ eta (s (")"));
fun parens (p) {
  inbr (lParens, p, rParens)
}

-- Utility parsers
var comma = memo $ eta (s (","));
var semicolon = memo $ eta (s (";"));

-- Expression
var primaryExp = memo $ eta syntax (
  x=decimal { Const (stringInt (x)) }
| x=lident  { Var (x) }
| parens[exp]
),
    exp = memo $ eta (expr (binops, primaryExp));

-- Assignment statement
var assignSign = memo $ eta (s (":="));
var stmtAssign = memo $ eta syntax (v=lident assignSign nv=exp { Assn (v, nv) });

-- If statement
fun halfIf (expr, thenStmt) {
  fun (elseStmt) {
    If (expr, thenStmt, elseStmt)
  }
}
fun accum (stmt, halfIf) {
  halfIf (stmt)
}
var elifP = memo $ eta syntax (kElif e=exp kThen s=stmt { halfIf (e, s) });
var ifP = memo $ eta syntax (kIf e=exp kThen s=stmt { halfIf (e, s) });
var elseP = memo $ eta syntax (s=(-kElse stmt)? { s.orDefault (Skip) });
var stmtIf = memo $ eta syntax (sThen=ifP sElif=elifP* sElse=elseP kFi { foldr (accum, sElse, sThen:sElif) });

-- While statement
var stmtWhile = memo $ eta syntax (kWhile e=exp kDo s=stmt kOd { While (e, s) });

-- For statement
var stmtFor = memo $ eta syntax (
  kFor sInit=stmt comma e=exp comma sCounter=stmt kDo sBody=stmt kOd
  { Seq (sInit, While (e, Seq (sBody, sCounter))) }
);

-- Do-While statement
var stmtDoWhile = memo $ eta syntax (kDo s=stmt kWhile e=exp kOd { DoWhile (s, e) });

-- Single statement
var primaryStmt = memo $ eta syntax (
  kRead v=parens[lident] { Read (v) }
| kWrite v=parens[exp] { Write (v) }
| kSkip { Skip }
| stmtAssign
| stmtIf
| stmtWhile
| stmtFor
| stmtDoWhile
);

-- List of statements
fun seqB (l, r) {
  Seq (l, r)
}
var stmt = memo $ eta syntax (head=primaryStmt tail=(-semicolon primaryStmt)* { foldl (seqB, head, tail) });

-- Full program
var program = memo $ eta syntax (stmt -end);

-- Public top-level parser
public parse = program;
             
