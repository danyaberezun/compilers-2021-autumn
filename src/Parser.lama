-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun parens(p) {
  inbr (s ("("), p, s (")"))
}

fun binop (l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (
    x=decimal {Const (stringInt (x))}
  | x=lident {Var (x)}
  | parens[exp]
);

var exp = memo $ eta expr ({
  [Left, {
    [s ("!!"), binop]
  }],
  [Left, {
    [s ("&&"), binop]
  }],
  [Nona, {
    [s ("<"), binop],
    [s ("<="), binop],
    [s (">"), binop],
    [s (">="), binop],
    [s ("=="), binop],
    [s ("!="), binop]
  }],
  [Left, {
    [s ("+"), binop],
    [s ("-"), binop]
  }],
  [Left, {
    [s ("*"), binop],
    [s ("/"), binop],
    [s ("%"), binop]
  }]
}, primary);

var stmt = memo $ eta syntax (
    kRead
    x=parens[lident]
    {Read (x)}
  | kWrite
    x=parens[exp]
    {Write (x)}
  | kSkip {Skip}
  | to=lident
    s[":="]
    from=exp
    {Assn (to, from)}
);

var compoundStmt = memo $ eta syntax (
    stmt
  | head=stmt
    s[";"]
    tail=compoundStmt
    {Seq (head, tail)}
);
   

-- Public top-level parser
public parse = compoundStmt;
