-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

fun evalInst (c, inst) {
  case c of [stack, state, world] ->
    case inst of
      READ ->
        case readWorld (world) of [value, newWorld] ->
          [value : stack, state, newWorld]
        esac
    | WRITE ->
        case stack of stackTop : stackTail ->
          [stackTail, state, writeWorld(stackTop, world)]
        esac
    | BINOP (op) ->
        case stack of rhs : lhs : stackTail ->
          var result = case op of
            "+"  -> lhs +  rhs
          | "-"  -> lhs -  rhs
          | "*"  -> lhs *  rhs
          | "/"  -> lhs /  rhs
          | "%"  -> lhs %  rhs
          | "==" -> lhs == rhs
          | "!=" -> lhs != rhs
          | "<"  -> lhs <  rhs
          | "<=" -> lhs <= rhs
          | ">"  -> lhs >  rhs
          | ">=" -> lhs >= rhs
          | "&&" -> lhs && rhs
          | "!!" -> lhs !! rhs
          esac;
          [result : stackTail, state, world]
        esac
    | LD (varName) ->
        [state (varName) : stack, state, world]
    | ST (varName) ->
        case stack of stackTop : stackTail ->
          [stackTail, state <- [varName, stackTop], world]
        esac
    | CONST (intConst) ->
        [intConst : stack, state, world]
    esac
  esac
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  case insns of
    lastInst : headInsts ->
      evalInst (eval (c, headInsts), lastInst)
  | {} -> c
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions.
fun compileExpr (expr, instList) {
  case expr of
    Var (varName) -> LD (varName) : instList
  | Const (int) -> CONST (int) : instList
  | Binop (op, lhs, rhs) ->
      BINOP (op) : compileExpr (rhs, compileExpr (lhs, instList))
  esac
}

fun compileSMImpl (stmt, instList) {
  case stmt of
    Assn (varName, expr) ->
      ST (varName) : compileExpr (expr, instList)
  | Seq (firstStmt, nextStmts) ->
      compileSMImpl (nextStmts, compileSMImpl (firstStmt, instList))
  | Skip -> instList
  | Read (varName) ->
      ST (varName) : READ : instList
  | Write (expr) ->
      WRITE : compileExpr(expr, instList)
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  compileSMImpl(stmt, {})
}
