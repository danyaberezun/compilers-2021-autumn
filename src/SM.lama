-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
-- conf is: [top_s, st, w]
fun eval ([top_s, st, w], insns) {
  case insns of
    ins:t -> case ins of
      READ -> (
            var outR = readWorld(w);
            eval([outR.fst:top_s, st, outR.snd], t)
      )
      | WRITE -> case top_s of
            h:tail -> (
                var outR = writeWorld(h, w);
                eval([tail, st, outR], t)
        )
        esac
      | BINOP (op) -> case top_s of
        x:y:tail -> (
            var res = binOp(op, y, x);
            eval([res:tail, st, w], t)
        )
       esac
      | LD (x) -> eval ([st(x):top_s, st, w], t)
      | ST (x) -> case top_s of
            h:tail -> eval([tail, st <- [x, h], w], t)
       esac
      | CONST (x) -> eval([x:top_s, st, w], t)
    esac
  | {} -> [top_s, st, w]
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list 
-- of stack machine instructions
fun compileExpr (expr) {
--  printf("%s", expr);
  case expr of
   -- i did not get why listBuffer(LD(x)) could not be used
    Var (x) -> { LD (x)}
   | Const (x) -> { CONST(x)}
   | Binop (op, x, y) -> (
        var l = compileExpr(x);
        var r = compileExpr(y);
        l +++ r +++ { BINOP(op) }
    )
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
    case stmt of
       Assn (st, expr) -> compileExpr(expr) +++ { ST(st) }
      | Seq (st, stR) -> compileSM(st) +++ compileSM(stR)
      | Read (st) -> {READ, ST(st)}
      | Write (expr) -> compileExpr(expr) +++ {WRITE}
    esac
}
