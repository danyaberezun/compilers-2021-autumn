-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

fun evalCJmp([stack, st, w], cond, label, env, suffix) {
  case case stack of
    0:stack -> case cond of
                 "nz" -> [stack, suffix] |
                 "z" -> [stack, fromLabel (env, label)]
                esac |
    _:stack -> case cond of
                 "nz" -> [stack, fromLabel (env, label)] |
                 "z" -> [stack, suffix]
               esac
  esac of
    [stack, insns] -> [[stack, st, w], insns]
  esac
}


-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, in) {
  case in of
    READ : in     -> eval (env, [readWorld(c[2])[0]:c[0], c[1], readWorld(c[2])[1]], in) |
    WRITE : in    -> eval (env, [c[0].snd, c[1], writeWorld (c[0].fst, c[2])], in) |
    BINOP (op) : in -> eval (env, funcBinop (c, op), in) |
    LD (name) : in -> eval (env, [c[1](name):c[0], c[1], c[2]], in) |
    ST (name) : in -> eval (env, [c[0].snd, c[1] <- [name, c[0].fst], c[2]], in) |
    CONST (value) : in -> eval (env, [value:c[0], c[1], c[2]], in) |
    JMP (hl) : in -> eval (env, c, env[0](hl)) |
    CJMP (cd, hl) : in -> case evalCJmp (c, cd, hl, env, in) of
                                    [c, in] -> eval (env, c, in)
                                  esac |
    LABEL (hl) : in -> eval (env, c, in) |
    LDA (name) : in         -> eval (env, [Ref(name):c.fst, c.snd, c[2]], in) |
    STI : in              -> eval (env, funcSti(c[2], c[1], c[0]), in) |
    DROP : in               -> eval (env, [c[0].snd, c[1], c[2]], in) |
    DUP : in               -> eval (env, [c[0].fst:c[0].fst:c[0].snd, c[1], c[2]], in)  |
    {}         -> c |
    _ -> failure("Error in eval-no such expr\n")
  esac
}

fun evalInsnDrop ([value:stack, st, w]) {
  [stack, st, w]
}

fun evalInsnDup ([value:stack, st, w]) {
  [value:value:stack, st, w]
}


fun funcSti (w, st,  value:Ref (varName):stack) {
  [value:stack, st <- [varName, value], w]
}


-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}


fun funcBinop ([x1:x2:y, st, w], inc) {
  var ex = case inc of
    "+"  -> x2 +  x1 |
    "-"  -> x2 -  x1 |
    "*"  -> x2 *  x1 |
    "/"  -> x2 /  x1 |
    "%"  -> x2 %  x1 |
    ">=" -> x2 >= x1 |
    "&&" -> x2 && x1 |
    "==" -> x2 == x1 |
    "!=" -> x2 != x1 |
    "<"  -> x2 <  x1 |
    "<=" -> x2 <= x1 |
    ">"  -> x2 >  x1 |
    "!!" -> x2 !! x1 |
    _    -> failure ("Failure at funcBinop - Incorrect expression for binop\n")
  esac;
  [ex:y, st, w]
}

fun funcIf (e, l, n) {
  case genLabel (e) of
    [y, e] ->
      case compileExpr (l[1], e) of
        [d, e] ->
          case case l[2] of
                 If (_, _, _) -> funcIf (e, l[2], n) |
                 _ -> compileExpr (l[2], e)
               esac of
            [h, e] ->
             [compileExpr (l[0]) <+ CJMP ("nz", y) <+> h <+ JMP (n) <+
              LABEL (y) <+> d, e]
          esac
      esac
  esac
}


fun funcEstm(fstArr, sndArr, mode, cd){
		case mode of
                 "X" -> (case cd of
			"z" -> sndArr |
                 	"nz" -> fstArr
                	 
                	esac)|
                 "Y" -> (case cd of
			"z" -> fstArr |
                 	"nz" -> sndArr
                      	esac)
                esac
}


-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr, env) {
  case expr of
    Var   (_)          -> [singletonBuffer (LD (expr[0])), env] |
    Const (_)          -> [singletonBuffer (CONST (expr[0])), env] |
    Ref (_)            -> [singletonBuffer (LDA (expr[0])), env] |
    Binop (_, _, _)    -> (case compileExpr (expr[1], env) of
    				[leftInsns, env] ->
    				case compileExpr (expr[2], env) of
      					[rightInsns, env] -> [leftInsns <+> rightInsns <+ BINOP (expr[0]), env]
    				esac
  			   esac) |
    Assn  (Ref (_), _) -> (case compileExpr (expr[1], env) of
    				[insns, env] -> [insns <+ DUP <+ ST (expr[0][0]), env]
  			   esac) |
    Assn (_, _)        -> (case compileExpr (expr[0], env) of
    				[refInsns, env] ->
    				case compileExpr (expr[1], env) of
      					[insns, env] -> [refInsns <+> insns <+ STI, env]
    				esac
  			   esac) |
    Seq   (_, _)       -> (case compileExpr (expr.fst, env) of
    					[x1, env] -> case compileExpr (expr.snd, env) of
                      					[x2, env] -> [x1 <+> x2, env]
                    				   esac
  		    	   esac) | 
    Skip               -> [{}, env]                      |
    Read  (Ref (_))    -> [listBuffer ({READ, ST (expr[0][0])}), env] |
    Write (_)          -> (case compileExpr (expr[0], env) of
    				[insns, env] -> [insns <+ WRITE, env]
  			   esac) |
    While (_, _)       -> (case genLabels (env, 2) of
    				[start, cond, env] ->
      				case compileExpr(expr[1], env) of
        				[stmtInsns, env] ->
        					case compileExpr (expr[0], env) of
          					[exprInsns, env] -> [singletonBuffer (JMP (cond)) <+ LABEL (start) <+> stmtInsns <+ LABEL (cond) <+>
                               			exprInsns <+ CJMP ("nz", start),  env]
        					esac
      					esac
  				esac) |
    DoWhile (_, _)     -> (case genLabel (env) of
    				[start, env] ->
      					case compileExpr(expr[0], env) of
        					[stmtInsns, env] ->
        				case compileExpr (expr[1], env) of
          					[exprInsns, env] -> [singletonBuffer (LABEL (start)) <+> stmtInsns <+>
                               			exprInsns <+ CJMP ("nz", start),  env]
        				esac
      				esac
  			  esac) |
    If (_, _, _)       -> (case genLabel (env) of
    				[thenEnd, env] ->
      				case compileExprIfExit (expr, thenEnd, env) of
        				[insns, env] -> [insns <+ LABEL (thenEnd), env]
      				esac
  			  esac) |
    Ignore (_)         -> (case compileExpr (expr[0], env) of
    				[exprInsns, env] -> [exprInsns <+ DROP, env]
  			  esac) |
    _                  -> failure (sprintf("compileExpr for %s not implemented\n", string(expr)))
  esac
}

fun compileExprIfExit (If (expr, stmtThen, stmtElse), exitLabel, env) {
  case genLabel (env) of
    [thenStart, env] ->
      case compileExpr (stmtThen, env) of
        [instThen, env] ->
          case case stmtElse of
                 If (_, _, _) -> compileExprIfExit (stmtElse, exitLabel, env) |
                 _ -> compileExpr (stmtElse, env)
               esac of
            [instElse, env] ->
            case compileExpr(expr, env) of
              [exprInsns, env] -> [exprInsns <+ CJMP ("nz", thenStart) <+> instElse <+ JMP (exitLabel) <+
                                  LABEL (thenStart) <+> instThen, env]
            esac
          esac
      esac
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case compileExpr (stmt, initCompEnv()) of
    [in, i] -> getBuffer (in)
  esac
}

