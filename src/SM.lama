-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP %s, %s", c, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];

  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, cfg @ [stack, state, world], insns) {
  case insns of
    {} -> cfg
  | JMP (label) : _ -> eval (env, cfg, env.fromLabel (label))
  | CJMP (cond, label) : is ->
      case stack of
        value : tail -> eval (env, [tail, state, world],
          if
            case cond of
              "z" -> value == 0
            | "nz" -> value != 0
            esac
          then env.fromLabel (label)
          else is fi
        )
      esac
  | i : is -> eval(env,
    case i of
      READ ->
        case readWorld (world) of
          [value, world] -> [value : stack, state, world]
        esac
    | WRITE ->
        case stack of
          value : tail -> [tail, state, writeWorld (value, world)]
        esac
    | BINOP (opStr) ->
        case stack of
          right : left : tail -> [evalOp (opStr, left, right) : tail, state, world]
        esac
    | LD (name) -> [state (name) : stack, state, world]
    | LDA (ref) -> [ref : stack, state, world]
    | ST (name) ->
        case stack of
          value : tail -> [tail, state <- [name, value], world]
        esac
    | STI ->
        case stack of
          value : addr : tail -> [value : tail, state <- [addr, value], world]
        esac
    | CONST (value) -> [value : stack, state, world]
    | LABEL (_) -> cfg
    | DUP ->
        case stack of
          x : tail -> [x : x : tail, state, world]
        esac
    | DROP ->
        case stack of
          _ : tail -> [tail, state, world]
        esac
    esac, is)
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [sprintf ("L%d", n), makeCompEnv (n+1)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Utility function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case env.genLabel of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun label (lab, labUsed) {
    if labUsed
    then singletonBuffer (LABEL (lab))
    else emptyBuffer ()
    fi
  }

  fun compile (lab, env, stmt) {
    case stmt of
      Skip           -> [false, env, emptyBuffer ()]
    | Var (name)     -> [false, env, singletonBuffer (LD (name))]
    | Ref (name)     -> [false, env, singletonBuffer (LDA (name))]
    | Const (value)  -> [false, env, singletonBuffer (CONST (value))]
    | Read (x)       -> [false, env, singletonBuffer (READ) <+ ST (x)]
    | Write (expr)   ->
        case env.genLabel of
          [writeLabel, env] ->
            case compile (writeLabel, env, expr) of
              [writeLabelUsed, env, exprCode] ->
                [false, env,
                  exprCode <+>
                  label (writeLabel, writeLabelUsed) <+
                  WRITE
                ]
            esac
        esac
    | Assn (dest, src) ->
        case env.genLabels (2) of
          [afterDestLabel, afterSrcLabel, env] ->
            case compile (afterDestLabel, env, dest) of
              [afterDestLabelUsed, env, destCode] ->
                case compile (afterSrcLabel, env, src) of
                  [afterSrcLabelUsed, env, srcCode] ->
                    [false, env,
                      destCode <+>
                      label (afterDestLabel, afterDestLabelUsed) <+>
                      srcCode <+>
                      label (afterSrcLabel, afterSrcLabelUsed) <+
                      STI
                    ]
                esac
            esac
        esac
    | Binop (op, left, right) ->
        case env.genLabels (2) of
          [afterLeftLabel, afterRightLabel, env] ->
            case compile (afterLeftLabel, env, left) of
              [afterLeftLabelUsed, env, leftCode] ->
                case compile (afterRightLabel, env, right) of
                  [afterRightLabelUsed, env, rightCode] ->
                    [false, env,
                      leftCode <+>
                      label (afterLeftLabel, afterLeftLabelUsed) <+>
                      rightCode <+>
                      label (afterRightLabel, afterRightLabelUsed) <+
                      BINOP (op)
                    ]
                esac
            esac
        esac
    | Seq (s1, s2) ->
        case env.genLabel of
          [s2Lab, env] ->
              case compile (s2Lab, env, s1) of
                [s2LabUsed, env, s1Code] ->
                  case compile (lab, env, s2) of
                    [labUsed, env, s2Code] -> [labUsed, env, s1Code <+> label (s2Lab, s2LabUsed) <+> s2Code]
                  esac
              esac
        esac
    | If (condExpr, trueExpr, falseExpr) ->
        case env.genLabels (2) of
          [ifLabel, elseLabel, env] ->
            case compile (ifLabel, env, condExpr) of
              [ifLabelUsed, env, condCode] ->
                case compile (lab, env, trueExpr) of
                  [_, env, trueCode] ->
                    case compile (lab, env, falseExpr) of
                      [_, env, falseCode] ->
                        [true, env,
                          condCode <+>
                          label (ifLabel, ifLabelUsed) <+
                          CJMP ("z", elseLabel) <+>
                          trueCode <+
                          JMP (lab) <+
                          LABEL (elseLabel) <+>
                          falseCode
                        ]
                    esac
                esac
            esac
        esac
    | While (cond, body) ->
        case env.genLabel of
          [nextLabel, env] ->
            case compile (nextLabel, env, cond) of
              [_, env, condCode] ->
                case compile (nextLabel, env, body) of
                  [_, env, bodyCode] ->
                    [true, env,
                      singletonBuffer (LABEL (nextLabel)) <+>
                      condCode <+
                      CJMP ("z", lab) <+>
                      bodyCode <+
                      JMP (nextLabel)
                    ]
                esac
            esac
        esac
    | DoWhile (body, cond) ->
        case env.genLabels (2) of
          [nextLabel, afterBodyLabel, env] ->
            case compile (nextLabel, env, cond) of
              [_, env, condCode] ->
                case compile (afterBodyLabel, env, body) of
                  [afterBodyLabelUsed, env, bodyCode] ->
                    [false, env,
                      singletonBuffer (LABEL (nextLabel)) <+>
                      bodyCode <+>
                      label (afterBodyLabel, afterBodyLabelUsed) <+>
                      condCode <+
                      CJMP ("nz", nextLabel)
                    ]
                esac
            esac
        esac
    | Ignore (expr) ->
        case env.genLabel of
          [dropLabel, env] ->
            case compile (dropLabel, env, expr) of
              [dropLabelUsed, env, exprCode] -> [false, env,
                exprCode <+>
                label (dropLabel, dropLabelUsed) <+
                DROP
              ]
            esac
        esac
    | _ -> failure ("compileSM not implemented\n")
    esac
  }

  case initCompEnv ().genLabel of
    [endLab, env] ->
       case compile (endLab, env, stmt) of
         [endLabUsed, _, code] -> getBuffer $ code <+> label (endLab, endLabUsed)
       esac
  esac
}
