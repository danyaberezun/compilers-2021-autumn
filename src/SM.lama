-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> x
    esac
  }

  case i of
    READ             -> "READ"
  | WRITE            -> "WRITE"
  | BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | STI              -> "STI"
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (s)       -> sprintf ("LABEL %s", s)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (c, l)    -> sprintf ("CJMP %s, %s", c, l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];

  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, w, insns) {
  -- Global state maps names of global variables to values
  var globalState = ref (fun (x) {error (sprintf ("name ""%s"" is undefined", x), getLoc (x))});

  -- Make a fresh local state: a pair of arrays for arguments and local variables;
  -- takes the numbers of arguments and local variables respectively
  fun makeState (a, l) {
    [initArray (a, fun (_) {0}), initArray (l, fun (_) {0})]
  }

  -- Lookups a location in local/global states
  fun lookup ([args, locs], loc) {

    var value = case loc of
      Arg (i) -> args[i]
    | Loc (i) -> locs[i]
    | Glb (x) -> deref (globalState) (x)
    esac;
    -- printf("lookup(): loc=%s, v=%s\n", loc.string, value.string);

    value
  }

  -- Assigns a value to a location
  fun assign ([args, locs], loc, v) {

    case loc of
      Arg (i) -> args[i] := v
    | Loc (i) -> locs[i] := v
    | Glb (x) -> var g = deref (globalState);
                 globalState ::= fun (y) {if compare (x, y) == 0 then v else g (y) fi}
    esac;

    -- printf("assign(): loc=%s, v=%s\n\n", loc.string, v.string);

    [args, locs]
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take (list, n) {
    fun inner (n, acc, list) {
      if n == 0
      then [list, acc]
      else inner (n-1, list.hd : acc, list.tl)
      fi
    }

    inner (n, {}, list)
  }


  fun createLocalState (stack, nArgs, nLocals) {
    case take(stack, nArgs) of
      [stack, args] -> 
        case foldl (
          fun ([st, n], arg) {
            [assign (st, Arg (n), arg), n + 1]
          }, [makeState (nArgs, nLocals), 0], args)
        of
          [st, _] -> [stack, st]
        esac
    esac
  }


  -- Returns either new configuration for program or new configuration and new program instructions that are left to execute
  -- Returns: c | [c, insns]
  fun evalSingleInsn (env, c@[stack, controlStack, st, w], ins, insnsToExecute) {
    printf("evalSingleInsn(): ins=%s, stack=%s\n", ins.string, stack.string);

    case ins of
      GLOBAL (x) -> [stack, controlStack, assign (st, Glb (x), 0), w]
    | BEGIN  (fLab, nArgs, nLocals) -> 
      case createLocalState(stack, nArgs, nLocals) of
        [stack, st] -> [stack, controlStack, st, w]
      esac
    | END  -> 
      case controlStack of
        [st, insns] : restCst -> [[stack, restCst, st, w], insns]
      | {} -> [c, {}]
      esac
    | CALL (fLab, nArgs) -> [[stack, [st, insnsToExecute] : controlStack, st, w], fromLabel (env, fLab)]
    | READ ->
        case readWorld (w) of
          [v, wld] -> [v : stack, controlStack, st, wld]
        esac
    | WRITE -> [tl (stack), controlStack, st, writeWorld (hd (stack), w)]
    | BINOP (op) ->
      case stack of 
        y : x : rest -> [evalOp (op, x, y) : rest, controlStack, st, w]
      | _ -> failure ("Stack does not have enough elements. Required >=2 for BINOP.")
      esac
    | LD  (x) -> [lookup (st, x) : stack, controlStack, st, w]
    | LDA (x) -> [x : stack, controlStack, st, w]
    | ST  (x) -> [stack, controlStack, assign (st, x, hd (stack)), w]
    | STI     ->
      case stack of
        v : x : rest -> [v : rest, controlStack, assign (st, x, v), w]
      | _ -> failure ("Stack does not have enough elements. Required >=2 for STI.")
      esac
    | DROP   -> [tl (stack), controlStack, st, w]
    | CONST (n) -> [n : stack, controlStack, st, w]
    | LABEL (s) -> c
    | JMP (l) -> [c, fromLabel (env, l)]
    | CJMP (cond, l) ->
      case [cond, hd (stack)] of 
        ["nz", 0] -> [tl (stack), controlStack, st, w]
      | ["z",  0] -> [[tl (stack), controlStack, st, w], fromLabel (env, l)]
      | ["nz", _] -> [[tl (stack), controlStack, st, w], fromLabel (env, l)]
      | ["z",  _] -> [tl (stack), controlStack, st, w]
      esac
    esac
  }

  -- Core interpreter: takes a configuration and a program, returns a configuration
  (* Assignment *)
  fun eval (c@[st, cst, s, w], insns) {
    -- printf("eval(): c=%s, insns=%s\n", c.string, insns.string);
    -- fun getLength (arr) {
    --   case arr of
    --     a : rest -> (1 + getLength (rest))
    --   | _ -> 0 
    --   esac
    -- }
    -- printf("eval(): insnsLen=%s\n", insns.string);

    case insns of 
      {} -> c
    | ins : rest ->
        case evalSingleInsn (env, c, ins, rest) of
          [c, prog] -> eval (c, prog)
        | c         -> eval (c, rest)
        esac
    esac
    -- failure ("SM interpreter is not implemented\n")
  }

  
  printf ("eval(): instructions=\n%s\n\n", insns.string);
  (* End *)

  eval ([{}, {}, makeState (0, 0), w], insns) [3].getOutput
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), createWorld (input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [sprintf ("L%d", nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
  }

  -- Adds a new function
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScope (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScope (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar (name) {
    if scopeDepth == 1
    then makeCompEnv (nLabels, scopeDepth, addName (state, name, Glb (name)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addName (state, name, Loc (nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }

  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 1, enterFunction (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [functions, makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, {})]
  }

  -- Lookups a name of a variable
  fun lookupVar (name) {
    case lookup (state, name) of
      Fun (_, _) -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookup (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if scopeDepth == 1
     then [sprintf ("L%s", name),             makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions)]
     else [sprintf ("L%s_%d", name, nLabels), makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions)]
     fi
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 1
  }

  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel (env) {
  env [0] ()
}

fun rememberFun (env, name, args, body) {
  env [1] (name, args, body)
}

fun beginScope (env) {
  env [2] ()
}

fun endScope (env) {
  env [3] ()
}

fun addArg (env, name) {
  env [4] (name)
}

fun addVar (env, name) {
  env [5] (name)
}

fun beginFun (env, state) {
  env [6] (state)
}

fun getFuns (env) {
  env [7] ()
}

fun lookupVar (env, name) {
  env [8] (name)
}

fun lookupFun (env, name) {
  env [9] (name)
}

fun getLocals (env) {
  env [10] ()
}

fun genFunLabel (env, name) {
  env [11] (name)
}

fun addFun (env, name, fLabel, nargs) {
  env [12] (name, fLabel, nargs)
}

fun isGlobal (env) {
  env [13] ()
}

-- Helper function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case genLabel (env) of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
  foldl (fun (env, name) {addArg (env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars (env, names) {
  foldl (fun (env, name) {addVar (env, name)}, env, names)
}

-- Helper function: add definitions (functions and variables) to environment 
-- returns a pair [ new environment, code for GLOBAL definitions/empty array if scope was not global ]

fun addDefs (env, defs) {
  fun generateCodeForGlobals (names) {
    foldl (fun (code, name) {
      code <+ GLOBAL (name)
    }, emptyBuffer (), names)
  }

  foldl (fun ([ env, code ], def) {
    case def of
      Fun (name, args, body) ->
        case genFunLabel (env, name) of
          [fLab, env] -> [addFun (env, name, fLab, size (args)), code]
        esac
    | Var (vars) ->
      [
        addVars (env, vars),
        if isGlobal (env) then code <+> generateCodeForGlobals (vars) else code fi 
      ] 
    esac
  }, [ env, emptyBuffer () ], defs)
}

-- Helper function, remembers all functions from list of definitions (definition might contain Vars as well)
fun rememberFuns (env, defs) {
  foldl (fun (env, def) {
    case def of
      Fun (name, args, body) ->
        case lookupFun (env, name) of
          Fun (fLab, _) -> rememberFun (env, fLab, args, body)
        esac
    | _ -> env
    esac
  }, env, defs)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.

(* Assignment *)

-- Some guidelines for compiling functions and scopes.
--
-- 1. use env.beginScope/env.endScope properly;
-- 2. in each scope traverse the definitions twice:
--    a. first, add all bindings into symbolic state,
--       using end.addVar/env.addFun;
--    b. do not forget to generate GLOBAL instructions for
--       top-level variable declarations;
--    c. on the secord traversal add functions themselves for
--       future code generation (use env.rememberFun).
-- 3. the overall flow for code generation:
--    a. generate the code for the topmost expression (the program itself);
--    b. take list of nested functions definitions via env.getFuns and
--       generate the code for each function;
--    c. repeat b. until no function definitions appear.
-- 4. when compiling functions, do not forget to create proper
--    environment (use env.beginFun) and register arguments
--    (use env.addArg).

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  -- Generates a buffer with an optional label
  --    lab     --- the name of the label
  --    labUsed --- a flag if the lebel is needed
  fun label (lab, labUsed) {
    if labUsed
    then singletonBuffer (LABEL (lab))
    else emptyBuffer ()
    fi
  }

  -- compiles remembered functions
  -- returns: code for all functions
  fun compileFuns (env) {
    case getFuns (env) of 
    [funs, env] -> 
      foldl (fun ([env, code], func@(Fun (fLabel, args, body, state))) {
        case genLabel (env) of
          [lab, env] ->
            case compile (lab, addArgs (beginFun (env, state), args), body) of
              [used, fEnv, fBodyCode] -> [
                env,
                code <+ LABEL (fLabel) <+ BEGIN (fLabel, size (args), getLocals (fEnv)) <+> fBodyCode <+> label (lab, used) <+ END
              ]
            esac
        esac
      }, [env, emptyBuffer ()], funs).snd -- take second value from pair [env, code]
    esac
  }

  -- compiles parameter to perform function call
  -- returns [updated env, code for compiled parameters]
  fun compileArgs (env, params) {
    foldl (fun ([env, code], param) {
      case genLabel (env) of
        [lab, env] -> 
          case compile (lab, env, param) of
            [used, env, paramCode] -> [env, code <+> paramCode <+> label (lab, used)]
          esac
      esac
    }, [env, emptyBuffer ()], params)
  }

  -- Generates SM code for a given statement
  --    lab  --- a label to go to after the statement is executed
  --    env  --- compilation environment
  --    stmt --- a statement to generate SM code for
  -- Returns a triple:
  --    boolean flag indicating if "lab" was used
  --    updated environment
  --    code buffer  
  fun compile (lab, env, stmt) {
    case stmt of
      Scope (defs, e)  ->
        case addDefs (beginScope (env), defs) of
          [env, codeWithGlobals] ->
            case compile (lab, rememberFuns (env, defs), e) of
              [used, env, scopeCode] -> [used, endScope (env), codeWithGlobals <+> scopeCode]
            esac
        esac
    | Call   (name, params) -> 
      case compileArgs (env, params) of
        [env, argsCode] -> 
          case lookupFun (env, name) of
            Fun (fLab, nArgs) -> [false, env, argsCode <+ CALL (fLab, nArgs)]
          esac
      esac
    | Skip              -> [false, env, emptyBuffer ()]
    | Var    (x)        -> [false, env, singletonBuffer (LD (lookupVar (env, x)))]
    | Ref    (x)        -> [false, env, singletonBuffer (LDA (lookupVar (env, x)))]
    | Const  (n)        -> [false, env, singletonBuffer (CONST (n))]
    | Ignore (e)        ->
        case env.genLabel of 
          [lab1, env] ->
            case compile (lab1, env, e) of
              [used, env, code] -> [false, env, code <+> label (lab1, used) <+ DROP]
            esac
        esac
    | Binop  (op, e1, e2) ->
        case env.genLabels(2) of
          [lab1, lab2, env] ->
            case compile (lab1, env, e1) of
              [used1, env, code1] ->
                case compile (lab2, env, e2) of
                  [used2, env, code2] -> [false, env, code1 <+> label (lab1, used1) <+> code2 <+> label (lab2, used2) <+ (BINOP (op))]
                esac
            esac
        esac
    | Read   (x)          -> [false, env, singletonBuffer (READ) <+ ST (lookupVar (env, x)) <+ DROP]
    | Write  (e)          ->
        case env.genLabel of
          [lab1, env] -> 
            case compile (lab1, env, e) of
              [used1, env, code] -> [false, env, code <+> label (lab1, used1) <+ WRITE]
            esac
        esac
    | Assn   (x, e)       ->
        case env.genLabels(2) of 
          [labX, labE, env] ->
            case compile (labX, env, x) of
              [usedX, env, codeX] ->
                case compile (labE, env, e) of
                  [usedE, env, codeE] -> [false, env, codeX <+> label (labX, usedX) <+> codeE <+> label (labE, usedE) <+ STI]
                esac
            esac
        esac
    | Seq    (s1, s2)     ->
        case env.genLabel of
          [s2Lab, env] ->
              case compile (s2Lab, env, s1) of
                [s2LabUsed, env, s1Code] ->
                  case compile (lab, env, s2) of
                    [labUsed, env, s2Code] -> [labUsed, env, s1Code <+> label (s2Lab, s2LabUsed) <+> s2Code]
                  esac
              esac
        esac
    | If     (e, s1, s2)  -> 
        case env.genLabel of
          [conditionFalseLabel, env] ->
            case compile (lab, env, s1) of
              [_, env, trueBranchCode] ->
                case compile (lab, env, s2) of
                  [_, env, falseBranchCode] ->
                    case env.genLabel of 
                      [exprLabel, env] ->
                        case compile (exprLabel, env, e) of
                          [exprLabelUsed, env, exprCode] -> [true, env, exprCode <+> label (exprLabel, exprLabelUsed) <+ CJMP ("z", conditionFalseLabel) <+> trueBranchCode <+ JMP (lab) <+ LABEL (conditionFalseLabel) <+> falseBranchCode]
                        esac
                    esac
                esac
            esac
        esac
    | While  (e, s)       ->
        case env.genLabels(3) of
          [conditionLabel, bodyLabel, exprLabel, env] ->
            case compile (conditionLabel, env, s) of
              [_, env, bodyCode] ->
                case compile (exprLabel, env, e) of
                  [exprLabelUsed, env, exprCode] -> [false, env, singletonBuffer (JMP (conditionLabel)) <+ LABEL (bodyLabel) <+> bodyCode <+ LABEL (conditionLabel) <+> exprCode <+> label (exprLabel, exprLabelUsed) <+ CJMP ("nz", bodyLabel)]
                esac
            esac
        esac
    | DoWhile (s, e)      ->
        case env.genLabels(3) of
          [bodyLabel, conditionLabel, exprLabel, env] -> 
            case compile (conditionLabel, env, s) of
              [_, env, bodyCode] ->
                case compile (exprLabel, env, e) of
                  [exprLabelUsed, env, exprCode] -> [false, env, singletonBuffer (LABEL (bodyLabel)) <+> bodyCode <+ LABEL (conditionLabel) <+> exprCode <+> label (exprLabel, exprLabelUsed) <+ CJMP ("nz", bodyLabel)]
                esac
            esac
        esac
    | _                   ->  failure ("compileSM not implemented\n")
    esac
  }

  case initCompEnv ().genLabel of
    [endLab, env] ->
      -- printf ("compile(): stmt=\n%s\n\n", stmt.string);

      case compile (endLab, env, stmt) of
        [endLabUsed, env, code] ->
          -- adding main function is need for proper state initialization in eval() function. The state is dependent on the number of arguments of "scope" and the number of local variables inside "scope". Since only functions actually create a new scope in our code, then we need to create a function for global scope as well. Otherwise, state with be create of size (args: 0, local: 0), which for "locals" might not be correct.
          getBuffer $ singletonBuffer (LABEL ("main")) <+ BEGIN ("main", 0, getLocals (env)) <+> code <+> label (endLab, endLabUsed) <+ END <+> compileFuns (env)
      esac
  esac
}

