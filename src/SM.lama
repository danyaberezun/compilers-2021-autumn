-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c@[st, s, w], insns) {
  case insns of 
    {} -> c 
    | i : insns_ -> 
      eval(case i of
        READ -> case readWorld (w) of [x, w] -> [x : st, s, w] esac
        | WRITE -> case st of (x : st_) -> [st_, s, writeWorld(x, w)] esac
        | BINOP (op) -> case st of (y : x : st_) -> [evalOp (op, x, y) : st_, s, w] esac
        | CONST (x) -> [x : st, s, w] 
        | LD (x) -> [s(x) : st, s, w]
        | ST (x) -> case st of (st_val : st_) -> [st_, (s <- [x, st_val]), w] esac
      esac, insns_)
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list 
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of 
    Var (x) -> {LD (x)}
  | Const (num) -> {CONST (num)}
  | Binop(op, exp_left, exp_right) -> 
    var eval_left = compileExpr(exp_left);
    var eval_right = compileExpr(exp_right);
    eval_left +++ eval_right +++ {BINOP (op)}
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of 
    Skip -> {}
    | Assn (x, expr) -> compileExpr(expr) +++ {ST (x)}
    | Read (x) -> {READ, ST (x)}
    | Write (expr) -> compileExpr(expr) +++ {WRITE}
    | Seq (left_stmt, right_stmt) -> compileSM(left_stmt) +++ compileSM(right_stmt)
  esac
}
