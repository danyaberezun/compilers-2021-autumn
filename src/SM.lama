-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
    READ             -> sprintf("READ")
  | WRITE            -> sprintf("WRITE")
  | CONST(value)     -> sprintf("CONST %d", value)
  | BINOP(operation) -> sprintf("BINOP %s", operation)
  | LD(variableName) -> sprintf("LD %s", variableName)
  | ST(variableName) -> sprintf("ST %s", variableName)
  esac
}

public fun showSM(prg) {
  map(fun(i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}

fun evaluateInstruction(configuration, command) {
  var stack = configuration[0];
  var state = configuration[1];
  var world = configuration[2];

  case command of
    CONST(value) -> [value:stack, state, world]
  | READ -> (
      var valueWorld = readWorld(world);
      var value = valueWorld.fst;
      var newWorld = valueWorld.snd;
      [value:stack, state, newWorld]
  )
  | WRITE -> (
      case stack of
        value:newStack -> [newStack, state, writeWorld(value, world)]
      | _ -> failure("evaluateInstruction/write: Empty stack")
      esac
  )
  | BINOP(operation) -> (
      case stack of
        r:l:rest -> (
          var value = calculateBinaryOperation(operation, l, r);
          [value:rest, state, world]
      )
      | _ -> failure("evaluateInstruction/binop: Insufficient operands")
      esac
  )
  | LD(variableName) -> [state(variableName):stack, state, world]
  | ST(variableName) -> (
    case stack of
      value:newStack -> [newStack, state <- [variableName, value], world]
    | _ -> failure("evaluateInstruction/st: Empty stack")
    esac
  )
  esac
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration.
fun eval(configuration, insns) {
  case insns of
    l:r -> eval(evaluateInstruction(configuration, l), r)
  | {}  -> configuration
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval([{}, emptyState, createWorld(input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a buffer of stack machine instructions.
fun compileExpr(expression) {
  case expression of
    Var(variableName) -> singletonBuffer(LD(variableName))
  | Const(value) -> singletonBuffer(CONST(value))
  | Binop(operation, l, r) ->
      (compileExpr(l) <+> compileExpr(r)) <+ (BINOP(operation))
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a buffer of stack machine instructions.
fun compileSMBuffer(statement) {
  case statement of
    Skip -> emptyBuffer()
  | Seq(l, r) -> compileSMBuffer(l) <+> compileSMBuffer(r)
  | Read(variableName) -> listBuffer({ READ, ST(variableName) })
  | Write(expression) -> compileExpr(expression) <+ WRITE
  | Assn(variableName, expression) ->
      compileExpr(expression) <+ ST(variableName)
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine instructions.
public fun compileSM(statement) {
  getBuffer(compileSMBuffer(statement))
}
