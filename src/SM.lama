-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  case c of 
    [valueStack, state, world] ->
      case insns of
        head:tailInsns -> 
          case head of
            ST (varName) -> 
              case valueStack of
                x:tail -> eval([tail, state <- [varName, x], world], tailInsns)
              esac
            | CONST(n) -> eval([n : valueStack, state, world], tailInsns)
            | LD (varName) -> eval([state(varName) : valueStack, state, world], tailInsns)
            | BINOP (binopName) -> 
              case valueStack of
                x:y:tail -> eval([evalExpr(state, Binop(binopName, Const(y), Const(x))):tail, state, world], tailInsns)
              esac
            | READ -> 
              var sAndnewWorld = readWorld(world);
              case sAndnewWorld of
                [readSymbol, newWorld] -> eval([readSymbol: valueStack, state, newWorld], tailInsns)
              esac
            | WRITE -> 
              -- printf("Executing write!");
              case valueStack of
                x:tailStack -> eval([tailStack, state, writeWorld(x, world)], tailInsns)
              esac
            | _ -> printf("Match failed!\n")
          esac
        | _ -> c
      esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  -- printf("Compiled sm: \n%se\n\n", showSM(insns));
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Var (name) -> 
      -- printf("Called Var(%s)\n", name);
      LD(name):{}
    | Const (value) -> 
      -- printf("Called Const(%d)\n", value);
      CONST(value):{}
    | Binop (name, e1, e2) -> 
      -- printf("Called Binop(%s, ...)\n", name);
      compileExpr(e1) +++ compileExpr(e2) +++ (BINOP(name):{})
    -- | _ -> printf("Unexpeceted!"); 5
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  -- printf("compile begin\n");
  case stmt of 
      Assn(varName, expr) -> 
        -- printf("Called Assn to %s\n", varName);
        compileExpr(expr) +++ (ST(varName):{})
    | Skip -> []
    | Read (varName) -> 
      -- printf("Called Read to %s\n", varName);
      READ: ST(varName):{} 
    | Write (expr) -> 
      -- var u = printf("Called Write\n");
      var y = compileExpr(expr) +++ (WRITE:{});
      y
    | Seq (stmt1, stmt2) ->  
        -- var t = printf("Begin seq\n");
        var y = compileSM(stmt1) +++ compileSM(stmt2); y
    -- | _ -> printf("Unexpected!\n"); 5
  esac
}
