-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
    READ -> sprintf("READ")
    | WRITE -> sprintf("WRITE")
    | BINOP(s) -> sprintf("BINOP %s", s)
    | LD(x) -> sprintf("LD %s", x)
    | ST(x) -> sprintf("ST %s", x)
    | CONST(n) -> sprintf("CONST %d", n)
  esac
}

public fun showSM(prg) {
  map(fun (i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval(c@[stack, st, world], insns) {
  case insns of
    { } -> c
    | headInsns:tailInsns ->
      case headInsns of
        CONST(n) -> (
          var newStack = n:stack;
          eval([newStack, st, world], tailInsns)
        )
        | READ -> (
          var readResult = readWorld(world);
          var v = readResult.fst;
          var newWorld = readResult.snd;
          var newStack = v:stack;
          eval([newStack, st, newWorld], tailInsns)
        )
        | WRITE -> case stack of v:tailStack -> (
          var newWorld = writeWorld(v, world);
          eval([tailStack, st, newWorld], tailInsns)
        ) esac
        | BINOP(op) ->
          case stack of y:x:tailStack -> (
            var binopResult = evalBinaryOperation(op, x, y);
            var newStack = binopResult:tailStack;
            eval([newStack, st, world], tailInsns)
          ) esac
        | LD(x) -> (
          var newStack = st(x):stack;
          eval([newStack, st, world], tailInsns)
        )
        | ST(x) -> case stack of v:tailStack -> (
          var newState = st <- [x, v];
          eval([tailStack, newState, world], tailInsns)
        ) esac
      esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval([{ }, emptyState, createWorld(input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list
-- of stack machine instructions
fun compileExpr(expr) {
  case expr of
    Const(c) -> { CONST(c) }
    | Var(s) -> { LD(s) }
    | Binop(op, expr1, expr2) -> compileExpr(expr1) +++ compileExpr(expr2) +++ { BINOP(op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM(stmt) {
  case (stmt) of
    Skip -> { }
    | Assn(s, e) -> compileExpr(e) +++ { ST(s) }
    | Seq(s1, s2) -> compileSM(s1) +++ compileSM(s2)
    | Read(s) -> { READ, ST(s) }
    | Write(e) -> compileExpr(e) +++ { WRITE }
  esac
}
