-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
      READ      -> sprintf("READ")
    | WRITE     -> sprintf("WRITE")
    | BINOP (s) -> sprintf("BINOP %s", s)
    | LD    (x) -> sprintf("LD %s", x)
    | ST    (x) -> sprintf("ST %s", x)
    | CONST (n) -> sprintf("CONST %d", n)
  esac
}

public fun showSM(prg) {
  map(fun (i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval(c@[stack, state, world@[input, output]], insns) {
  sprintf("eval\n");
  case insns of
      { }            -> c
    | curInsn : tail ->
      showSMInsn(curInsn);
      eval(
        case curInsn of
            READ      -> case readWorld(world) of
              [n, newWorld] -> [n:stack, state, newWorld]
            esac
          | WRITE     -> case stack of
              n : restStack -> [restStack, state, writeWorld(n, world)]
            | _             -> failure("Empty stack during WRITE instruction\n")
          esac
          | BINOP (s) -> case stack of
              a : b : restStack -> [evalBinOp(s, b, a):restStack, state, world]
            | _                 -> failure("Not enough values for BINOP instruction\n")
          esac
          | LD (x)    -> [state(x):stack, state, world]
          | ST (x)    -> case stack of
            n : restStack -> [restStack, state <- [x, n], world]
            | _ -> failure("No value for ST instruction\n")
          esac
          | CONST (n) -> [n:stack, state, world]
        esac
        , tail
      )
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, insns) {
  eval([{ }, emptyState, createWorld(input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr(expr) {
  fun compileExprRecursion(expr) {
    case expr of
        Binop (op, expr1, expr2) -> compileExpr(expr1) +++ compileExpr(expr2) +++ { BINOP(op) }
      | Const (n)                -> { CONST(n) }
      | Var (variable)           -> { LD(variable) }
    esac
  }
  deepFlatten(compileExprRecursion(expr))
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM(stmt) {
--   sprintf("compileSM\n");
  fun compileSMRecursion(stmt) {
    case stmt of
        Assn (variable, expr) -> { compileExpr(expr), ST(variable) }
      | Read(variable)        -> { READ, ST(variable) }
      | Write(expr)           -> { compileExpr(expr), WRITE }
      | Seq (s1, s2)          -> { compileSM(s1), compileSM(s2) }
      | Skip                  -> { }
    esac
  }
  deepFlatten(compileSMRecursion(stmt))
}
