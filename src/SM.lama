-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c @ [stack, state, world], insns) {
  case insns of
    {} -> c              |
    insnsHead : insnsTail ->
      eval (
        case insnsHead of
          READ ->
            case readWorld(world) of
              [readInteger, newWorld] -> [
                readInteger : stack,  -- New stack with added readInteger
                state,                -- State with no changes
                newWorld              -- World after reading
              ]
            esac                                     |
          WRITE  ->
            case stack of
              top : rest -> [
                rest,                    -- Stack without taken top
                state,                   -- State with no changes
                writeWorld(top, world)   -- New world after writing top of a 
                                         -- stack
              ]
            esac                                     |
          BINOP(opStr) ->
            case stack of
              top1 : top2 : rest -> ( -- Take two integers from stack.
                  var newStack = evalBinOp(opStr, top2, top1) : rest;
                  [                 
                    newStack,          -- Stack with result of binary operation 
                                       -- on two top elements of stack
                    state,             -- State with no changes
                    world              -- World with no changes
                  ]
              )                                      |
              _ -> failure("Binary operation on invalid stack.")
            esac                                     |
          LD(x) -> [
            state(x) : stack,          -- Stack with x on top
            state,                     -- State with no changes
            world                      -- World with no changes
          ]                                          |
          ST(x) ->
            case stack of
              xValue : tail -> [
                tail,                 -- Stack without taken element
                state <- [x, xValue], -- State with new added binding for x
                world                 -- World with no editions.
              ]                                      |
              _ -> failure("ST operation with invalid stack.")
            esac                                     |
          CONST(n) -> [n : stack, state, world]
        esac,
        insnsTail
      )
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Var(x) ->   { LD(x) }                 |
    Const(c) -> { CONST(c) }              |
    Binop(op, l, r) -> compileExpr(l)
                       +++ compileExpr(r)
                       +++ { BINOP(op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
    Assn(x, expr) -> compileExpr(expr) +++ { ST(x) }   |
    Read(x) -> { READ, ST(x) }                         |
    Write(expr) -> compileExpr(expr) +++ { WRITE }     |
    Seq(f, s) -> compileSM(f) +++ compileSM(s)         |
    Skip -> {}
  esac
}