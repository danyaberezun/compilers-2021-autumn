-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;
import Ref;
import Expr;

var wordSizeBytes = 4;

-- x86 registers 
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];
-- Named synonyms for x86 registers
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We can freely operate with only this many registers
var nRegs = 4;

-- We need to distinguish the following operand types: 
--    R (int)       -- hard register                    
--    S (int)       -- a position on the hardware stack 
--    M (string)    -- a named memory location          
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   UnaryIMul (opnd)
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Cdq
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
                                                               
-- Renders an x86 instruction to a string in assembly syntax.
fun instructionToString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    | "test" -> "testl"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)    -> regs [i]
    | S (i)    -> sprintf ("-%d(%%ebp)", (i+1) * wordSizeBytes)
    | M (x)    -> x
    | L (i)    -> sprintf ("$%d", i)
    | I (0, x) -> sprintf ("(%s)", opndString (x))
    | I (n, x) -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }
  
  case insn of
    Cltd               -> "\tcltd\n"
  | Cdq                -> "\tcdq\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | UnaryIMul (s)      -> sprintf ("\timull\t%s\n", opndString (s))
  | Lea   (s1, s2)     -> sprintf ("\tleal\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  esac
}

fun setZero (reg) {
  -- Binop ("^", reg, reg)
  Mov (L (0), reg)
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  --| I (_, _) -> true
  | _     -> false
  esac
}

fun isAddSubSMInstruction (op) {
  case op of
    "+" -> true
  | "-" -> true
  | _ -> false
  esac
}

fun isMulSMInstruction (binopSign) {
  case binopSign of
    "*" -> true
  | _ -> false
  esac
}

fun isIDivBinopSMInstruction (op) {
  case op of
    "/" -> true
  | "%" -> true
  | _ -> false
  esac
}

fun isCmpBinopSMInstruction (binopSign) {
  case binopSign of
    "==" -> true
  | "!=" -> true
  | "<" -> true
  | "<=" -> true
  | ">" -> true
  | ">=" -> true
  | _ -> false
  esac
}

fun getFlagsSuffix (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "l"
  | "<=" -> "le"
  | ">" -> "g"
  | ">=" -> "ge"
  esac
}

fun getFlagsSuffixFlipped (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "g"
  | "<=" -> "ge"
  | ">" -> "l"
  | ">=" -> "le"
  esac
}

fun createCompiler () {
  -- Generated x86 assembly code.
  var code = ref $ emptyBuffer ();
  -- Set of declared global variables.
  var globals = ref $ emptySet (compare);
  -- Current symbolic stack.
  var currentStack = ref $ {};
  -- Maximum used depth of hardware stack.
  var maxStackDepth = ref $ 0;
  -- Map from label to the symbolic stack at this label.
  var stackMap = ref $ emptyMap (compare);
  -- Indicator that we are breaking the control flow by going to the current instruction from the previous one.
  var barrier = ref $ false;

  fun allocate () {
    var stack = deref (currentStack);
    case (
      case stack of
        {} -> [R (0), 0]
      | R (n) : _ -> if n+1 < nRegs then [R (n+1), 0] else [S (0), 1] fi
      | S (n) : _ -> [S (n+1), n+2]
      | other -> failure ("Unreachable " ++ string (other))
      esac
    ) of [location, depth] ->
      currentStack ::= location : stack;
      if depth > deref (maxStackDepth)
        then maxStackDepth ::= depth
      fi;
      location
    esac
  }

  fun pop () {
    case deref (currentStack) of top : tail ->
      currentStack ::= tail;
      top
    esac
  }

  fun pop2 () {
    case deref (currentStack) of top1 : top2 : tail ->
      currentStack ::= tail;
      [top1, top2]
    esac
  }

  fun push (operand) {
    case (operand) of
      L (imm) ->
        var operand = allocate ();
        addInst (Mov (L (imm), operand))
    | _ ->
        currentStack ::= operand : deref (currentStack)
    esac
  }

  fun peek () {
    case deref (currentStack) of top : _ ->
      top
    esac
  }

  fun acquireGlobal (x) {
    var globalName = "global_" ++ x;
    globals ::= addSet (deref (globals), globalName);
    M (globalName)
  }

  fun addInst (x86Inst) {
    code ::= deref (code) <+ x86Inst
  }

  fun addInsts (x86Insts) {
    code ::= deref (code) <+> x86Insts
  }

  fun saveStack (label) {
    stackMap ::= addMap (
      deref (stackMap),
      label,
      deref (currentStack)
    )
  }

  fun retrieveStack (label) {
    case findMap (deref (stackMap), label) of
      Some (stack) ->
        currentStack ::= stack
    | None ->
        skip
    esac
  }

  fun setBarrier () {
    barrier ::= true
  }

  fun setNoBarrier () {
    barrier ::= false
  }

  fun isBarrier () {
    deref (barrier)
  }

  fun compileRead () {
    var operand = allocate ();
    addInst (Call ("Lread"));
    addInst (Mov (eax, operand))
  }

  fun compileWrite () {
    var operand = pop ();
    addInst (Push (operand));
    addInst (Call ("Lwrite"));
    addInst (Pop (eax))
  }

  -- \pre left operand is not an immediate
  fun compileCmp (suffix, lOperand, rOperand) {
    if memOpnd (lOperand) && memOpnd (rOperand) then
      addInst (Mov (rOperand, eax));
      addInst (Binop ("cmp", eax, lOperand))
    else
      addInst (Binop ("cmp", rOperand, lOperand))
    fi;
    addInst (setZero (eax));
    addInst (Set (suffix, "%al"));
    addInst (Mov (eax, allocate ()))
  }

  fun compileRegisterTestZero (register) {
    addInst (Binop ("test", register, register))
  }

  fun compileTestZero (operand) {
    if memOpnd (operand) then
      addInst (Mov (operand, eax));
      compileRegisterTestZero (eax)
    else
      compileRegisterTestZero (operand)
    fi
  }

  fun compileToBooleanToEax (operand) {
    compileTestZero (operand);
    addInst (setZero (eax));
    addInst (Set ("ne", "%al"))
  }

  fun compileToBoolean (operand) {
    compileToBooleanToEax (operand);
    addInst (Mov (eax, allocate ()))
  }

  fun compileLogicalBinopWithOneImmediate (op, operand, immediate) {
    case op of
      "&&" ->
        if immediate == 0 then
          push (L (0))
        else
          compileToBoolean (operand)
        fi
    | "!!" ->
        if immediate == 0 then
          compileToBoolean (operand)
        else
          push (L (1))
        fi
    esac
  }

  fun compileBinop (op) {
    case pop2 () of [rOperand, lOperand] ->

      fun compileIDiv () {
        var resultReg = case op of
          "/" -> eax
        | "%" -> edx
        esac;
        addInst (Mov (lOperand, eax));
        addInst (Cdq);
        case rOperand of
          L (_) ->
            var holder = allocate ();
            addInsts (move (rOperand, holder));
            addInst (IDiv (holder));
            pop ()
        | _ ->
            addInst (IDiv (rOperand))
        esac;
        addInst (Mov (resultReg, allocate ()))
      }

      fun nonConstant () {
        if isIDivBinopSMInstruction (op) then
          compileIDiv ()
        else
          case [lOperand, rOperand] of
            [L (lImm), rOperand] ->
              if isAddSubSMInstruction (op) then
                case op of
                  "-" ->
                    addInst (Mov (L (lImm), eax));
                    addInst (Binop ("-", rOperand, eax));
                    addInst (Mov (eax, rOperand));
                    push (rOperand)
                | "+" ->
                    addInst (Binop ("+", L (lImm), rOperand));
                    push (rOperand)
                esac
              elif isMulSMInstruction (op) then
                addInst (Mov (L (lImm), eax));
                addInst (UnaryIMul (rOperand));
                addInst (Mov (eax, allocate ()))
              elif isCmpBinopSMInstruction (op) then
                compileCmp (getFlagsSuffixFlipped (op), rOperand, lOperand)
              else
                compileLogicalBinopWithOneImmediate (op, rOperand, lImm)
              fi
          | [lOperand, L (rImm)] ->
              if isAddSubSMInstruction (op) then
                addInst (Binop (op, L (rImm), lOperand));
                push (lOperand)
              elif isMulSMInstruction (op) then
                addInst (Mov (L (rImm), eax));
                addInst (UnaryIMul (lOperand));
                addInst (Mov (eax, allocate ()))
              elif isCmpBinopSMInstruction (op) then
                compileCmp (getFlagsSuffix (op), lOperand, rOperand)
              else
                compileLogicalBinopWithOneImmediate (op, lOperand, rImm)
              fi
          | [lOperand, rOperand] ->
              if isAddSubSMInstruction (op) then
                addInst (Mov (lOperand, eax));
                addInst (Binop (op, rOperand, eax));
                addInst (Mov (eax, allocate ()))
              elif isMulSMInstruction (op) then
                addInst (Mov (lOperand, eax));
                addInst (UnaryIMul (rOperand));
                addInst (Mov (eax, allocate ()))
              elif isCmpBinopSMInstruction (op) then
                compileCmp (getFlagsSuffix (op), lOperand, rOperand)
              else
                compileToBooleanToEax (lOperand);
                addInst (Mov (eax, edx));
                compileToBooleanToEax (rOperand);
                (
                  var resultOperand = allocate ();
                  addInst (Mov (eax, resultOperand));
                  addInst (Binop (op, edx, resultOperand))
                )
              fi
          esac
        fi
      }

      case [lOperand, rOperand] of
        [L (lImm), L (rImm)] ->
          push (L (evalOp (op, lImm, rImm)))
      | _ ->
          nonConstant ()
      esac
    esac
  }

  fun compileLd (x) {
    var variable = acquireGlobal (x);
    addInsts (move (variable, allocate ()))
  }

  fun compileLda (x) {
    var variable = acquireGlobal (x);
    var resultOperand = allocate ();
    if memOpnd (resultOperand) then
      addInst (Lea (variable, eax));
      addInst (Mov (eax, resultOperand))
    else
      addInst (Lea (variable, resultOperand))
    fi
  }

  fun compileSt (x) {
    var variable = acquireGlobal (x);
    var operand = peek ();
    addInsts (move (operand, variable))
  }

  fun compileSti (x) {
    case pop2 () of [valueOperand, refOperand] ->
      addInsts (move (valueOperand, I (0, refOperand)));
      push (valueOperand)
    esac
  }

  fun compileConst (n) {
    push (L (n))
  }

  fun compileLabel (label) {
    if isBarrier () then
      retrieveStack (label);
      setNoBarrier ()
    fi;
    addInst (Label (label))
  }

  fun compileJmp (label) {
    saveStack (label);
    addInst (Jmp (label));
    setBarrier ()
  }

  fun compileCJmp (cond, label) {
    var condOperand = pop ();
    case condOperand of
      L (condImm) ->
        var needJump = case cond of
          "z" -> condImm == 0
        | "nz" -> condImm != 0
        esac;
        if needJump then
          compileJmp (label)
        fi
    | _ ->
        compileTestZero (condOperand);
        saveStack (label);
        addInst (CJmp (cond, label))
    esac
  }

  fun compileDup () {
    push (peek ())
  }

  fun compileDrop () {
    pop ()
  }

  fun compileInst (smInst) {
    addInst (Meta ("# " ++ showSMInsn (smInst) ++ "\n"));
    case smInst of
      READ -> compileRead ()
    | WRITE -> compileWrite ()
    | BINOP (op) -> compileBinop (op)
    | LD (x) -> compileLd (x)
    | LDA (x) -> compileLda (x)
    | ST (x) -> compileSt (x)
    | STI -> compileSti ()
    | CONST (n) -> compileConst (n)
    | LABEL (label) -> compileLabel (label)
    | JMP (label) -> compileJmp (label)
    | CJMP (cond, label) -> compileCJmp (cond, label)
    | DUP -> compileDup ()
    | DROP -> compileDrop ()
    | _ -> failure ("Unsupported SM instruction %s\n", string (smInst))
    esac
  }

  fun compileSMProgram (smCode) {
    iter (compileInst, smCode)
  }

  [
    code,
    globals,
    maxStackDepth,
    compileSMProgram
  ]
}

-- Get generated x86 assembly code as a buffer.
fun cGetCode (compiler) {
  deref $ compiler[0]
}

-- Get the list of declared global variables.
fun cGetGlobals (compiler) {
  elements (deref $ compiler[1])
}

-- Get the maximum used depth of hardware stack.
fun cGetMaxStackDepth (compiler) {
  deref $ compiler[2]
}

-- Compile a stack machine program into a list of x86 instruction.
fun cCompileSMProgram (compiler, smCode) {
  compiler[3] (smCode)
}

-- Generates data definition
fun globalIntDefinition (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
fun prologue (size) {
  singletonBuffer (Push (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", L (wordSizeBytes*size), esp)
}

-- Generates function epilogue
fun epilogue () {
  singletonBuffer (Mov (ebp, esp)) <+
  Pop   (ebp) <+
  Binop ("^", eax, eax) <+
  Ret
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
    then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
    else singletonBuffer (Mov (from, to))
  fi
}

-- A top-level codegeneration function.
-- Takes a driver's environment and a stack machine program,
-- compiles the program into machine code,
-- and links the machine code into an executable.
-- \param code List of stack machine instructions, from first to last.
public fun compileX86 (args, code) {
  var compiler = createCompiler ();
  cCompileSMProgram (compiler, code);
  (
    var asmInstructions = cGetCode (compiler);
    var globalIntDefinitions = map (globalIntDefinition, cGetGlobals (compiler));
    var wholeProgram = singletonBuffer (Meta ("\t.global\tmain\n")) <+>
      singletonBuffer (Meta ("\t.data\n")) <+>
      listBuffer (globalIntDefinitions) <+>
      singletonBuffer (Meta ("\t.text\n")) <+>
      singletonBuffer (Meta ("main:\n")) <+>
      prologue (cGetMaxStackDepth (compiler)) <+>
      asmInstructions <+>
      epilogue ();
    var asmCode = stringcat (map (instructionToString, getBuffer (wholeProgram)));
    var asmFile = args.getBaseName ++ ".s";
    var runtime = case getEnv ("LAMA_RUNTIME") of
      #val  -> "../runtime/"
    | path  -> path
    esac ++ "/runtime.o";
    var gccCommand = stringcat ({
      "gcc -g -m32 -no-pie -o ",
      getBaseName (args),
      " ",
      runtime,
      " ",
      asmFile
    });
    fwrite (asmFile, asmCode);
    system (gccCommand)
  )
}
