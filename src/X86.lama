-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;
import Ref;
import Expr;

fun listTake (k, list) {
  case list of
    {} -> {}
  | head : tail ->
      if k == 0 then
        {}
      else
        head : listTake (k - 1, tail)
      fi
  esac
}

fun listDrop (k, list) {
  if k == 0 then
    list
  else
    case list of
      {} -> {}
    | _ : tail -> listDrop (k - 1, tail)
    esac
  fi
}

var wordSizeBytes = 4;

-- x86 registers 
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];
-- Named synonyms for x86 registers
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We can freely operate with only this many registers
var nRegs = 4;

-- We need to distinguish the following operand types: 
-- data X86Operand
--    R (int)       -- hard register                    
--    S (int)       -- a position on the hardware stack 
--    M (string)    -- a named memory location          
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
-- data X86Instruction =
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   UnaryIMul (opnd)
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Cdq
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
--   Dec   (opnd)               -- arithmetic correction: decrement  
--   Or1   (opnd)               -- arithmetic correction: or 0x0001                     
--   Sal1  (opnd)               -- arithmetic correction: shl 1           
--   Sar1  (opnd)               -- arithmetic correction: shr 1
-- 
-- data X86Code = Buffer X86Instruction
                                                               
-- Renders an x86 instruction to a string in assembly syntax.
fun instructionToString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    | "test" -> "testl"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)    -> regs [i]
    | S (i)    -> 
        if i >= 0 then
          sprintf ("-%d(%%ebp)", (i+1) * wordSizeBytes)
        else
          sprintf ("%d(%%ebp)", 8 - (i+1) * wordSizeBytes)
        fi
    | M (x)    -> x
    | L (i)    -> sprintf ("$%d", i)
    | I (0, x) -> sprintf ("(%s)", opndString (x))
    | I (n, x) -> sprintf ("%d(%s)", n, opndString (x))
    | _ -> failure ("Invalid X86Operand %s\n", string (opnd))
    esac
  }
  
  case insn of
    Cltd               -> "\tcltd\n"
  | Cdq                -> "\tcdq\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | UnaryIMul (s)      -> sprintf ("\timull\t%s\n", opndString (s))
  | Lea   (s1, s2)     -> sprintf ("\tleal\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  | Dec   (s)          -> sprintf ("\tdecl\t%s\n", opndString (s))
  | Or1   (s)          -> sprintf ("\torl\t$0x0001,\t%s\n", opndString (s))
  | Sal1  (s)          -> sprintf ("\tsall\t%s\n", opndString (s))
  | Sar1  (s)          -> sprintf ("\tsarl\t%s\n", opndString (s))    
  esac
}

fun setZero (reg) {
  -- Binop ("^", reg, reg)
  Mov (L (0), reg)
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | I (_, _) -> true
  | _     -> false
  esac
}

fun isAddSubSMInstruction (op) {
  case op of
    "+" -> true
  | "-" -> true
  | _ -> false
  esac
}

fun isMulSMInstruction (binopSign) {
  case binopSign of
    "*" -> true
  | _ -> false
  esac
}

fun isIDivBinopSMInstruction (op) {
  case op of
    "/" -> true
  | "%" -> true
  | _ -> false
  esac
}

fun isCmpBinopSMInstruction (binopSign) {
  case binopSign of
    "==" -> true
  | "!=" -> true
  | "<" -> true
  | "<=" -> true
  | ">" -> true
  | ">=" -> true
  | _ -> false
  esac
}

fun getFlagsSuffix (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "l"
  | "<=" -> "le"
  | ">" -> "g"
  | ">=" -> "ge"
  esac
}

fun getFlagsSuffixFlipped (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "g"
  | "<=" -> "ge"
  | ">" -> "l"
  | ">=" -> "le"
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
    then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
    else singletonBuffer (Mov (from, to))
  fi
}

fun makeImmediateBox (n) {
  n * 2 + 1
}

-- data X86SymStack = List X86Operand

-- Create SM -> X86 compiler (codegenerator).
--
-- \return X86Compiler
fun createCompiler () {
  -- Generated x86 assembly code.
  --
  -- rCode : Ref X86Code
  var rCode = ref (emptyBuffer ());

  -- Set of declared global variables.
  --
  -- rGlobals : Ref (Set String)
  var rGlobals = ref (emptySet (compare));

  -- Set of declared global string literals: (name, value) pairs.
  --
  -- rStrings : Ref [String, String]
  var rStrings = ref (emptySet (compare));

  -- Index of the next string literal.
  --
  -- rStringIndex : Ref Int
  var rStringIndex = ref (0);

  -- Current symbolic stack.
  -- 
  -- rCurrentStack : Ref X86SymStack
  var rCurrentStack = ref ({});

  -- Maximum used depth of hardware stack.
  --
  -- rMaxStackDepth : Ref Int
  var rMaxStackDepth = ref (0);

  -- Map from label to the symbolic stack at this label.
  --
  -- rStackMap : Ref (Map String X86SymStack)
  var rStackMap = ref (emptyMap (compare));

  -- Indicator that we are breaking the control flow by going to the current instruction from the previous one.
  --
  -- rBarrier : Ref Bool
  var rBarrier = ref (false);

  -- Label of the current function.
  --
  -- rFunctionLabel : Ref String
  var rFunctionLabel = ref ("main");

  -- Number of local variables in this function.
  --
  -- rLocalsNo : Ref Int
  var rLocalsNo = ref (0);

  fun getStackSize () {
    deref (rMaxStackDepth)
  }

  fun allocate () {
    var stack = deref (rCurrentStack);
    var localsNo = deref (rLocalsNo);
    case (
      case stack of
        {} -> [R (0), 0]
      | R (n) : _ ->
          if n + 1 < nRegs then 
            [R (n + 1), 0]
          else
            [S (localsNo), localsNo + 1]
          fi
      | S (n) : _ -> [S (n + 1), n + 2]
      | other -> failure ("Unreachable " ++ string (other))
      esac
    ) of [location, depth] ->
      rCurrentStack ::= location : stack;
      if depth > deref (rMaxStackDepth)
        then rMaxStackDepth ::= depth
      fi;
      location
    esac
  }

  fun pop () {
    case deref (rCurrentStack) of top : tail ->
      rCurrentStack ::= tail;
      top
    esac
  }

  fun pop2 () {
    case deref (rCurrentStack) of top1 : top2 : tail ->
      rCurrentStack ::= tail;
      [top1, top2]
    esac
  }

  fun push (operand) {
    case (operand) of
      L (imm) ->
        var operand = allocate ();
        addInst (Mov (L (imm), operand))
    | _ ->
        rCurrentStack ::= operand : deref (rCurrentStack)
    esac
  }

  fun peek () {
    fst (deref (rCurrentStack))
  }

  fun getGlobalName (x) {
    "global_" ++ x
  }

  fun acquireGlobal (x) {
    var globalName = getGlobalName (x);
    rGlobals ::= addSet (deref (rGlobals), globalName);
    M (globalName)
  }

  fun loc (smLoc) {
    case smLoc of
      Glb (x) -> M (getGlobalName (x))
    | Arg (i) -> S (-1-i)
    | Loc (i) -> S (i)
    esac
  }

  fun addInst (x86Inst) {
    rCode ::= deref (rCode) <+ x86Inst
  }

  fun addInsts (x86Insts) {
    rCode ::= deref (rCode) <+> x86Insts
  }

  fun saveStack (label) {
    rStackMap ::= addMap (
      deref (rStackMap),
      label,
      deref (rCurrentStack)
    )
  }

  fun retrieveStack (label) {
    case findMap (deref (rStackMap), label) of
      Some (stack) ->
        rCurrentStack ::= stack
    | None ->
        skip
    esac
  }

  fun setBarrier () {
    rBarrier ::= true
  }

  fun setNoBarrier () {
    rBarrier ::= false
  }

  fun isBarrier () {
    deref (rBarrier)
  }

  fun currentFunction () {
    deref (rFunctionLabel)
  }

  fun isMain () {
    compare (currentFunction (), "main") == 0
  }

  -- Get the list of live registers past given symbolic stack depth.
  fun getLiveRegisters (depth) {
    fun inner (d, acc, st) {
      case st of
        {}             -> acc
      | (r@R (_)) : tl -> inner (d+1, if d >= depth then r : acc else acc fi, tl)
      | _         : tl -> inner (d+1, acc, tl)
      esac
    }

    inner (0, {}, deref (rCurrentStack))
  }

  -- Registers a string literal and assigns it a name
  fun addString (s) {
    var escaped = makeString ((s.length + 1) * 2), i = 0, j = 0, name = sprintf ("string_%d", deref (rStringIndex));
    for skip, i < s.length, i := i+1 do
      case s[i] of
        '"'  -> escaped [j] :='"'; escaped [j+1] := '"'; j := j+2
      | '\n' -> escaped [j] :='\'; escaped [j+1] := 'n'; j := j+2
      | '\t' -> escaped [j] :='\'; escaped [j+1] := 't'; j := j+2
      | c    -> escaped [j] := c; j := j+1
      esac
    od;
    rStringIndex ::= deref (rStringIndex) + 1;
    rStrings ::= addSet (deref (rStrings), [name, substring (escaped, 0, j)]);
    name
  }

  -- Gets a list of all string literals and their names
  fun getStrings () {
    elements (deref (rStrings))
  }

  -- Get a local static size for the current function.
  --
  -- \return Int
  fun getStaticSize () {
    deref (rLocalsNo) + deref (rMaxStackDepth)
  }

  fun unbox (loc) {
    addInst (Sar1 (loc))
  }

  fun boxIn (loc) {
    addInst (Sal1 (loc));
    addInst (Or1 (loc))
  }

  -- \pre left operand is not an immediate
  fun compileCmp (suffix, lOperand, rOperand) {
    addInst (Mov (rOperand, eax));
    unbox (eax);
    addInst (Mov (lOperand, edx));
    unbox (edx);
    addInst (Binop ("cmp", eax, edx));
    addInst (setZero (eax));
    addInst (Set (suffix, "%al"));
    boxIn (eax);
    addInst (Mov (eax, allocate ()))
  }

  fun compileRegisterTestZero (register) {
    addInst (Binop ("test", register, register))
  }

  fun compileTestZero (operand) {
    addInst (Mov (operand, eax));
    unbox (eax);
    compileRegisterTestZero (eax)
  }

  fun compileToBooleanToEax (operand) {
    compileTestZero (operand);
    addInst (setZero (eax));
    addInst (Set ("ne", "%al"))
  }

  fun compileToBoolean (operand) {
    compileToBooleanToEax (operand);
    boxIn (eax);
    addInst (Mov (eax, allocate ()))
  }

  fun compileBinop (op) {
    case pop2 () of [rOperand, lOperand] ->
      fun compileIDiv () {
        var resultReg = case op of
          "/" -> eax
        | "%" -> edx
        esac;
        addInst (Mov (lOperand, eax));
        unbox (eax);
        addInst (Cdq);
        unbox (rOperand);
        addInst (IDiv (rOperand));
        boxIn (resultReg);
        addInst (Mov (resultReg, allocate ()))
      }

      if isIDivBinopSMInstruction (op) then
        compileIDiv ()
      else
        if isAddSubSMInstruction (op) then
          addInst (Mov (lOperand, eax));
          unbox (eax);
          addInst (Mov (rOperand, edx));
          unbox (edx);
          addInst (Binop (op, edx, eax));
          boxIn (eax);
          addInst (Mov (eax, allocate ()))
        elif isMulSMInstruction (op) then
          addInst (Mov (lOperand, eax));
          unbox (eax);
          addInst (Mov (rOperand, edx));
          unbox (edx);
          addInst (UnaryIMul (edx));
          boxIn (eax);
          addInst (Mov (eax, allocate ()))
        elif isCmpBinopSMInstruction (op) then
          compileCmp (getFlagsSuffix (op), lOperand, rOperand)
        else
          compileToBooleanToEax (lOperand);
          addInst (Mov (eax, edx));
          compileToBooleanToEax (rOperand);
          addInst (Binop (op, edx, eax));
          boxIn (eax);
          addInst (Mov (eax, allocate ()))
        fi
      fi
    esac
  }

  fun compileLd (smLoc) {
    var location = loc (smLoc);
    addInsts (move (location, allocate ()))
  }

  fun addLea (location, resultOperand) {
    if memOpnd (resultOperand) then
      addInst (Lea (location, eax));
      addInst (Mov (eax, resultOperand))
    else
      addInst (Lea (location, resultOperand))
    fi
  }

  fun compileLda (smLoc) {
    var location = loc (smLoc);
    var resultOperand = allocate ();
    addLea (location, resultOperand)
  }

  fun compileSt (smLoc) {
    var location = loc (smLoc);
    var operand = peek ();
    addInsts (move (operand, location))
  }

  fun compileSti () {
    case pop2 () of [valueOperand, refOperand] ->
      addInsts (move (valueOperand, I (0, refOperand)));
      push (valueOperand)
    esac
  }

  fun compileConst (n) {
    push (L (makeImmediateBox (n)))
  }

  fun compileLabel (label) {
    if isBarrier () then
      retrieveStack (label);
      setNoBarrier ()
    fi;
    addInst (Label (label))
  }

  fun compileJmp (label) {
    saveStack (label);
    addInst (Jmp (label));
    setBarrier ()
  }

  fun compileCJmp (cond, label) {
    var condOperand = pop ();
    case condOperand of
      L (condImm) ->
        var needJump = case cond of
          "z" -> condImm == 0
        | "nz" -> condImm != 0
        esac;
        if needJump then
          compileJmp (label)
        fi
    | _ ->
        compileTestZero (condOperand);
        saveStack (label);
        addInst (CJmp (cond, label))
    esac
  }

  fun hwPushOperands (operands) {
    iter (fun (operand) {
      addInst (Push (operand))
    }, operands)
  }

  -- Compile CALL stack machine instruction.
  --
  -- \param functionLabel : String -- the label of the function to call.
  -- \param argumentsNo : Int -- number of arguments to take from the symbol stack.
  -- \param additionalArgs : [X86Operand] -- additional arguments to prepend at the beginning
  -- (in the same order).
  fun compileCall (functionLabel, argumentsNo, additionalArgs) {
    var arguments = listTake (argumentsNo, deref (rCurrentStack));
    var liveRegisters = getLiveRegisters (argumentsNo);
    rCurrentStack ::= listDrop (argumentsNo, deref (rCurrentStack));

    -- Save live registers
    hwPushOperands (liveRegisters);

    hwPushOperands (arguments);
    hwPushOperands (reverse (additionalArgs));

    addInst (Call (functionLabel));

    -- Discard arguments from the stack
    addInst (Binop ("+", L ((argumentsNo + size (additionalArgs)) * wordSizeBytes), esp));

    -- Restore live registers
    iter (fun (register) {
      addInst (Pop (register))
    }, reverse (liveRegisters));

    -- Push return value onto the symbolic stack
    addInst (Mov (eax, allocate ()))
  }

  -- Generates function prologue.
  --
  -- \param functionLabel : String
  fun prologue (functionLabel) {
    var functionStackSize = M (sprintf ("$%s_SIZE", functionLabel));
    addInst (Push (ebp));
    addInst (Mov (esp, ebp));
    addInst (Binop ("-", functionStackSize, esp))
  }

  -- Compile BEGIN stack machine instruction.
  --
  -- \param functionLabel : String
  -- \param argumentsNo : Int
  -- \param localsNo : Int
  fun compileBegin (functionLabel, argumentsNo, localsNo) {
    rCurrentStack ::= {};
    rMaxStackDepth ::= 0;
    rFunctionLabel ::= functionLabel;
    rLocalsNo ::= localsNo;
    rBarrier ::= false;
    addInst (Label (functionLabel));
    prologue (functionLabel)
  }

  -- Compile GLOBAL stack machine instruction.
  --
  -- \param x : String
  fun compileGlobal (x) {
    acquireGlobal (x)
  }

  -- Generate epilogue for the current function.
  fun epilogue () {
    var returnValueInst = if isMain() then
      setZero (eax)
    else
      var returnValue = pop ();
      Mov (returnValue, eax)
    fi;
    addInst (returnValueInst);
    addInst (Mov (ebp, esp));
    addInst (Pop (ebp));
    addInst (Ret);
    addInst (Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", currentFunction (), getStaticSize() * wordSizeBytes)))
  }

  -- Compile END stack machine instruction.
  fun compileEnd () {
    epilogue ()
  }

  fun compileDup () {
    push (peek ())
  }

  fun compileDrop () {
    pop ()
  }

  -- \param uident : String
  fun compileSexp (uident, elementsNo) {
    push (L (makeImmediateBox (tagHash (uident))));
    compileCall ("Bsexp", elementsNo + 1, {L (makeImmediateBox (elementsNo + 1))})
  }

  -- \param s : String
  fun compileString (s) {
    var name = addString (s);
    addLea (M (name), allocate());
    compileCall ("Bstring", 1, {})
  }

  -- \param n : Int
  fun compileArray (n) {
    compileCall("Barray", n, {L (makeImmediateBox (n))})
  }

  fun compileSta () {
    compileCall ("Bsta", 3, {})
  }

  fun compileElem () {
    compileCall ("Belem", 2, {})
  }

  fun compilePatt (pattern) {
    case pattern of
      Tag (t, n) ->
        compileCall ("Btag", 0, {peek (), L (makeImmediateBox (t)), L (makeImmediateBox (n))})
    | Array (n) ->
        compileCall ("Barray_patt", 0, {peek(), L (makeImmediateBox (n))})
    esac
  }

  -- Generate code for a stack machine instruction.
  --
  -- \param smInst : SMInstruction
  -- \return X86Code
  fun compileInst (smInst) {
    --printf ("X86.compileInst  %s\n", showSMInsn (smInst));
    addInst (Meta ("# " ++ showSMInsn (smInst) ++ "\n"));
    case smInst of
      BINOP (op) -> compileBinop (op)
    | LD (smLoc) -> compileLd (smLoc)
    | LDA (smLoc) -> compileLda (smLoc)
    | ST (smLoc) -> compileSt (smLoc)
    | STI -> compileSti ()
    | SEXP (uident, elementsNo) -> compileSexp (uident, elementsNo)
    | CONST (n) -> compileConst (n)
    | LABEL (label, _) -> compileLabel (label)
    | JMP (label) -> compileJmp (label)
    | CJMP (cond, label) -> compileCJmp (cond, label)
    | CALL (functionLabel, argumentsNo) -> compileCall (functionLabel, argumentsNo, {})
    | BEGIN (functionLabel, argumentsNo, localsNo) -> compileBegin (functionLabel, argumentsNo, localsNo)
    | GLOBAL (x) -> compileGlobal (x)
    | END -> compileEnd ()
    | DUP -> compileDup ()
    | DROP -> compileDrop ()
    | STRING (s) -> compileString (s)
    | ARRAY (n) -> compileArray (n)
    | STA -> compileSta ()
    | ELEM -> compileElem ()
    | PATT (pattern) -> compilePatt (pattern)
    | _ -> failure ("Unsupported SM instruction %s\n", string (smInst))
    esac
  }

  fun compileSMProgram (smCode) {
    --printf ("X86.compileSMProgram for smCode:\n%s\n\n", showSM (smCode));
    iter (compileInst, smCode)
  }

  fun genEpilogue () {
    failure ("TODO")
  }

  [
    rCode,
    rGlobals,
    rMaxStackDepth,
    compileSMProgram,
    getStrings
  ]
}

-- Get generated x86 assembly code.
--
-- \param compiler : X86Compiler
-- \return X86Code
fun cGetCode (compiler) {
  deref (compiler [0])
}

-- Get the list of declared global variables.
--
-- \param compiler : X86Compiler
-- \return List String -- list of names of declared global variables.
fun cGetGlobals (compiler) {
  elements (deref (compiler [1]))
}

fun cGetStrings (compiler) {
  compiler [4] ()
}

-- Get the maximum used depth of hardware stack.
--
-- \param compiler : X86Compiler
fun cGetMaxStackDepth (compiler) {
  deref (compiler [2])
}

-- Compile a stack machine program into a list of x86 instruction.
--
-- Compiled X86 assembler code can be obtained using cGetCode method.
--
-- \param compiler X86Compiler
-- \param smCode SMProgram
fun cCompileSMProgram (compiler, smCode) {
  compiler [3] (smCode)
}

fun globalIntDefinition (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

fun globalStringDefinition ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

-- A top-level codegeneration function.
-- Takes a driver's environment and a stack machine program,
-- compiles the program into machine code,
-- and links the machine code into an executable.
--
-- \param code : SMProgram
public fun compileX86 (args, code) {
  var compiler = createCompiler ();
  cCompileSMProgram (compiler, code);
  (
    var asmInstructions = cGetCode (compiler);
    var globalIntDefinitions = map (globalIntDefinition, cGetGlobals (compiler));
    var globalStringDefinitions = map (globalStringDefinition, cGetStrings (compiler));
    var wholeProgram = singletonBuffer (Meta ("\t.global\tmain\n")) <+>
      singletonBuffer (Meta ("\t.data\n")) <+>
      listBuffer (globalIntDefinitions) <+>
      listBuffer (globalStringDefinitions) <+>
      singletonBuffer (Meta ("\t.text\n")) <+>
      asmInstructions;
    --var p = printf("X86.compileX86 wholeProgram:\n%s\n\n", wholeProgram.getBuffer.string);
    var asmCode = stringcat (map (instructionToString, getBuffer (wholeProgram)));
    var asmFile = args.getBaseName ++ ".s";
    var runtime = case getEnv ("LAMA_RUNTIME") of
      #val  -> "../runtime/"
    | path  -> path
    esac ++ "/runtime.o";
    var gccCommand = stringcat ({
      "gcc -g -m32 -no-pie -o ",
      getBaseName (args),
      " ",
      runtime,
      " ",
      asmFile
    });
    fwrite (asmFile, asmCode);
    system (gccCommand)
  )
}


