-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;

var wordSizeBytes = 4;

-- x86 registers 
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];
-- Named synonyms for x86 registers
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We can freely operate with only this many registers
var nRegs = 4;

-- We need to distinguish the following operand types: 
--    R (int)    -- hard register                    
--    S (int)    -- a position on the hardware stack 
--    M (string) -- a named memory location          
--    L (int)    -- an immediate operand             

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Cdq
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name 
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
                                                               
-- Renders an x86 instruction to a string in assembly syntax.
fun instructionToString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    | "test" -> "testl"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i) -> regs [i]
    | S (i) -> sprintf ("-%d(%%ebp)", (i+1) * wordSizeBytes)
    | M (x) -> x
    | L (i) -> sprintf ("$%d", i)
    esac
  }
  
  case insn of
    Cltd               -> "\tcltd\n"
  | Cdq                -> "\tcdq\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Meta  (m)          -> m
  esac
}

fun setZero (reg) {
  -- Binop ("^", reg, reg)
  Mov (L (0), reg)
}

-- Environment for symbolic interpreter.
-- An environment holds:
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

fun isNotImmediate (entry) {
  case entry of
    L (_) -> false
  | _ -> true
  esac
}

fun makeEnv (stack, stackSlots, globals) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", string (stack), stackSlots, string (elements (globals)))
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate () {
    case 
      case filter (isNotImmediate, stack) of
        {}        -> [R (0), 0]
      | R (n) : _ -> if n+1 < nRegs then [R (n+1), 0] else [S (0), 1] fi
      | S (n) : _ -> [S (n+1), n+2]
      | other     -> failure ("Unreachable " ++ string (other))
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals)]
    esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals)]
    esac
  }

  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)))
  }

  -- References a global variable
  fun loc (name) {
    M (globalName (name))
  }
  
  -- Return the list of global variables from the environment
  fun getGlobals () {
    elements (globals)
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  [envString, allocate, push, pop, pop2, addGlobal, loc, getGlobals, getStackSize]
}

-- Exported accessors
fun envString (env) {
  env [0] ()
}

fun allocate (env) {
  env [1] ()
}

fun push (env, x) {
  env [2] (x)
}

fun pop (env) {
  env [3] ()
}

fun pop2 (env) {
  env [4] ()
}

fun addGlobal (env, name) {
  env [5] (name)
}

fun loc (env, name) {
  env [6] (name)
}

fun getGlobals (env) {
  env [7] ()
}

fun getStackSize (env) {
  env [8] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare))
}

-- Codegeneration helper functions

-- Generates data definition
fun globalIntDefinition (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
fun prologue (size) {
  singletonBuffer (Push (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", L (wordSizeBytes*size), esp)
}

-- Generates function epilogue
fun epilogue () {
  singletonBuffer (Mov (ebp, esp)) <+
  Pop   (ebp) <+
  setZero (eax) <+
  Ret
}

-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Generates a move between locations, using
-- intermediate register, if needed.
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

fun makeCompilerState (env, code) {
  fun csAddX86Instruction (x86Instruction) {
    makeCompilerState (env, code <+ x86Instruction)
  }

  fun csAllocate () {
    case allocate (env) of [location, env] ->
      [location, makeCompilerState (env, code)]
    esac
  }

  fun csPush (y) {
    makeCompilerState (push (env, y), code)
  }

  fun csPop () {
    case pop (env) of [operand, env] ->
    [operand, makeCompilerState (env, code)]
    esac
  }

  fun csPop2 () {
    case pop2 (env) of [rightOperand, leftOperand, env] ->
    [rightOperand, leftOperand, makeCompilerState (env, code)]
    esac
  }

  fun csGlobalVariable (variableIdentifier) {
    var newEnv = addGlobal (env, variableIdentifier);
    [loc (newEnv, variableIdentifier), makeCompilerState (newEnv, code)]
  }

  fun csAddX86Instructions (x86Instructions) {
    makeCompilerState (env, code <+> x86Instructions)
  }

  [csAddX86Instruction, csAllocate, csPush, csPop, csPop2, csGlobalVariable, env, code, csAddX86Instructions]
}

fun csAddX86Instruction (compilerState, x86Instruction) {
  compilerState [0] (x86Instruction)
}

fun csAllocate (compilerState) {
  compilerState [1] ()
}

fun csPush (compilerState, y) {
  compilerState [2] (y)
}

fun csPop (compilerState) {
  compilerState [3] ()
}

fun csPop2 (compilerState) {
  compilerState [4] ()
}

fun csGlobalVariable (compilerState, variableIdentifier) {
  compilerState [5] (variableIdentifier)
}

fun csEnv (compilerState) {
  compilerState [6]
}

fun csCode (compilerState) {
  compilerState [7]
}

fun csAddX86Instructions (compilerState, x86Instructions) {
  compilerState [8] (x86Instructions)
}

fun isSimpleBinopSMInstruction (binopSign) {
  case binopSign of
    "+" -> true
  | "-" -> true
  | "*" -> true
  | _ -> false
  esac
}

fun isIDivBinopSMInstruction (binopSign) {
  case binopSign of
    "/" -> true
  | "%" -> true
  | _ -> false
  esac
}

fun isCmpBinopSMInstruction (binopSign) {
  case binopSign of
    "==" -> true
  | "!=" -> true
  | "<" -> true
  | "<=" -> true
  | ">" -> true
  | ">=" -> true
  | _ -> false
  esac
}

fun getFlagsSuffix (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "l"
  | "<=" -> "le"
  | ">" -> "g"
  | ">=" -> "ge"
  esac
}

fun getFlagsSuffixFlipped (binopSign) {
  case binopSign of
    "==" -> "e"
  | "!=" -> "ne"
  | "<" -> "g"
  | "<=" -> "ge"
  | ">" -> "l"
  | ">=" -> "le"
  esac
}

fun evalBinop(binopSign, lhs, rhs) {
  case binopSign of
    "+" -> lhs + rhs
  | "-" -> lhs - rhs
  | "*" -> lhs * rhs
  | "/" -> lhs / rhs
  | "%" -> lhs % rhs
  | "==" -> lhs == rhs
  | "!=" -> lhs != rhs
  | "<" -> lhs < rhs
  | "<=" -> lhs <= rhs
  | ">" -> lhs > rhs
  | ">=" -> lhs >= rhs
  | "&&" -> lhs && rhs
  | "!!" -> lhs !! rhs
  esac
}

-- \pre left operand is not an immediate
fun compileCmpSMInstruction (compilerState, suffix, leftOperand, rightOperand) {
  compilerState := if memOpnd (leftOperand) && memOpnd (rightOperand) then
    compilerState := csAddX86Instruction (compilerState, Mov (rightOperand, eax));
    csAddX86Instruction (compilerState, Binop ("cmp", eax, leftOperand))
  else
    csAddX86Instruction (compilerState, Binop ("cmp", rightOperand, leftOperand))
  fi;
  compilerState := csAddX86Instruction (compilerState, setZero (eax));
  compilerState := csAddX86Instruction (compilerState, Set (suffix, "%al"));
  case csAllocate (compilerState) of [resultOperand, compilerState] ->
    csAddX86Instruction (compilerState, Mov (eax, resultOperand))
  esac
}

fun compileRegisterToBooleanToEax (compilerState, register) {
  compilerState := csAddX86Instruction (compilerState, Binop ("test", register, register));
  compilerState := csAddX86Instruction (compilerState, setZero (eax));
  csAddX86Instruction (compilerState, Set ("ne", "%al"))
}

fun compileToBooleanToEax (compilerState, operand) {
  if memOpnd (operand) then
    compilerState := csAddX86Instruction (compilerState, Mov (operand, eax));
    compileRegisterToBooleanToEax (compilerState, eax)
  else
    compileRegisterToBooleanToEax (compilerState, operand)
  fi
}

fun compileToBoolean (compilerState, operand) {
  compilerState := compileToBooleanToEax (compilerState, operand);
  case csAllocate (compilerState) of [resultOperand, compilerState] ->
    csAddX86Instruction (compilerState, Mov (eax, resultOperand))
  esac
}

fun compileLogicalBinopWithOneImmediate (compilerState, binopSign, operand, immediate) {
  case binopSign of
    "&&" ->
      if immediate == 0 then
        csPush (compilerState, L (0))
      else
        compileToBoolean (compilerState, operand)
      fi
  | "!!" ->
      if immediate == 0 then
        compileToBoolean (compilerState, operand)
      else
        csPush (compilerState, L (1))
      fi
  esac
}

fun compileBinopSMInstruction (compilerState, binopSign) {
  case csPop2 (compilerState) of [rightOperand, leftOperand, compilerState] ->

    fun compileIDiv () {
      var resultReg = case binopSign of
        "/" -> eax
      | "%" -> edx
      esac;
      compilerState := csAddX86Instruction (compilerState, Mov (leftOperand, eax));
      compilerState := csAddX86Instruction (compilerState, Cdq);
      compilerState := case rightOperand of
        L (_) -> 
          case csAllocate (compilerState) of [holder, compilerState] ->
            compilerState := csAddX86Instructions (compilerState, move (rightOperand, holder));
            compilerState := csAddX86Instruction (compilerState, IDiv (holder));
            case csPop (compilerState) of [_, compilerState] ->
              compilerState
            esac
          esac
      | _ -> csAddX86Instruction (compilerState, IDiv (rightOperand))
      esac;
      case csAllocate (compilerState) of [resultOperand, compilerState] ->
        csAddX86Instruction (compilerState, Mov (resultReg, resultOperand))
      esac
    }

    fun nonConstant() {
      if isIDivBinopSMInstruction (binopSign) then
        compileIDiv()
      else
        case [leftOperand, rightOperand] of 
          [L (leftImm), rightOperand] ->
            if isSimpleBinopSMInstruction (binopSign) then
              case binopSign of
                "-" ->
                  compilerState := csAddX86Instruction (compilerState, Mov (L (leftImm), eax));
                  compilerState := csAddX86Instruction (compilerState, Binop ("-", rightOperand, eax));
                  compilerState := csAddX86Instruction (compilerState, Mov (eax, rightOperand));
                  csPush (compilerState, rightOperand)
              | _ ->
                  compilerState := csAddX86Instruction (compilerState, Binop (binopSign, L (leftImm), rightOperand));
                  csPush (compilerState, rightOperand)
              esac
            elif isCmpBinopSMInstruction (binopSign) then
              compileCmpSMInstruction (compilerState, getFlagsSuffixFlipped (binopSign), rightOperand, leftOperand)
            else
              compileLogicalBinopWithOneImmediate (compilerState, binopSign, rightOperand, leftImm)
            fi
        | [leftOperand, L (rightImm)] ->
            if isSimpleBinopSMInstruction (binopSign) then
              compilerState := csAddX86Instruction (compilerState, Binop (binopSign, L (rightImm), leftOperand));
              csPush (compilerState, leftOperand)
            elif isCmpBinopSMInstruction (binopSign) then
              compileCmpSMInstruction (compilerState, getFlagsSuffix (binopSign), leftOperand, rightOperand)
            else
              compileLogicalBinopWithOneImmediate (compilerState, binopSign, leftOperand, rightImm)
            fi
        | [leftOperand, rightOperand] ->
            if isSimpleBinopSMInstruction (binopSign) then
              compilerState := csAddX86Instruction (compilerState, Mov (leftOperand, eax));
              compilerState := csAddX86Instruction (compilerState, Binop (binopSign, rightOperand, eax));
              case csAllocate (compilerState) of [resultOperand, compilerState] ->
                csAddX86Instruction (compilerState, Mov (eax, resultOperand))
              esac
            elif isCmpBinopSMInstruction (binopSign) then
              compileCmpSMInstruction (compilerState, getFlagsSuffix (binopSign), leftOperand, rightOperand)
            else
              compilerState := compileToBooleanToEax (compilerState, leftOperand);
              compilerState := csAddX86Instruction (compilerState, Mov (eax, edx));
              compilerState := compileToBooleanToEax (compilerState, rightOperand);
              case csAllocate (compilerState) of [resultOperand, compilerState] ->
                compilerState := csAddX86Instruction (compilerState, Mov (eax, resultOperand));
                csAddX86Instruction (compilerState, Binop (binopSign, edx, resultOperand))
              esac
            fi
        esac
      fi
    }

    case [leftOperand, rightOperand] of
      [L (leftImm), L (rightImm)] -> 
        csPush (compilerState, L (evalBinop (binopSign, leftImm, rightImm)))
    | _ ->
        nonConstant()
    esac
  esac
}

fun compileReadInstruction (compilerState) {
  case csAllocate (compilerState) of [stackTop, compilerState] ->
    compilerState := csAddX86Instruction (compilerState, Call ("Lread"));
    csAddX86Instruction (compilerState, Mov (eax, stackTop))
  esac
}

fun compileWriteInstruction (compilerState) {
  case csPop (compilerState) of [operand, compilerState] ->
    compilerState := csAddX86Instruction (compilerState, Push (operand));
    compilerState := csAddX86Instruction (compilerState, Call ("Lwrite"));
    csAddX86Instruction (compilerState, Pop (eax))
  esac
}

fun compileLdInstruction (compilerState, variableIdentifier) {
  case csGlobalVariable (compilerState, variableIdentifier) of [variable, compilerState] ->
    case csAllocate (compilerState) of [stackTop, compilerState] ->
      csAddX86Instructions (compilerState, move (variable, stackTop))
    esac
  esac
}

fun compileStInstruction (compilerState, variableIdentifier) {
  case csGlobalVariable (compilerState, variableIdentifier) of [variable, compilerState] ->
    case csPop (compilerState) of [operand, compilerState] ->
      csAddX86Instructions (compilerState, move (operand, variable))
    esac
  esac
}

fun compileSMInstruction (compilerState, smInstruction) {
  compilerState := csAddX86Instruction (compilerState, Meta ("# " ++ showSMInsn (smInstruction) ++ "\n"));
  case smInstruction of
    READ -> compileReadInstruction (compilerState)
  | WRITE -> compileWriteInstruction (compilerState)
  | BINOP (binopSign) -> compileBinopSMInstruction(compilerState, binopSign)
  | LD (variableIdentifier) -> compileLdInstruction (compilerState, variableIdentifier)
  | ST (variableIdentifier) -> compileStInstruction (compilerState, variableIdentifier)
  | CONST (number) -> csPush (compilerState, L (number))
  | _ -> failure ("Invalid SM instruction")
  esac
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, smProgram) {
  foldr (compileSMInstruction, makeCompilerState (env, emptyBuffer ()), smProgram)
}

-- A top-level codegeneration function. Takes a stack machine program
-- and returns x86 listing as a string
-- \param code List of stack machine instructions, head is the last instruction.
public fun compileX86 (args, code) {
  var finalState = compile (initEnv (), code);
  var env = csEnv (finalState);
  var compiledSMProgram = csCode (finalState);
  var globalIntDefinitions = map (globalIntDefinition, getGlobals (env));
  var wholeProgram = singletonBuffer (Meta ("\t.global\tmain\n")) <+>
    singletonBuffer (Meta ("\t.data\n")) <+>
    listBuffer (globalIntDefinitions) <+>
    singletonBuffer (Meta ("\t.text\n")) <+>
    singletonBuffer (Meta ("main:\n")) <+>
    prologue (getStackSize (env)) <+>
    compiledSMProgram <+>
    epilogue ();
  var asmCode = stringcat (map (instructionToString, getBuffer (wholeProgram)));
  var asmFile = args.getBaseName ++ ".s";
  var runtime = case getEnv ("LAMA_RUNTIME") of
    #val  -> "../runtime/"
  | path  -> path
  esac ++ "/runtime.o";
  var gccCommand = stringcat ({"gcc -g -m32 -o ", getBaseName (args), " ", runtime, " ", asmFile});
  fwrite (asmFile, asmCode);
  system (gccCommand)
}
