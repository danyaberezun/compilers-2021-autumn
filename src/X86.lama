-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import Fun;
import SM;
import Collection;
import List;
import Manifest;
import Buffer;

-- Assembler language interface
-- The registers:
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
var nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers:
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We need to know the word size to calculate offsets correctly
var wordSize = 4;

-- We need to distinguish the following operand types:
--    R (int)       -- hard register
--    S (int)       -- a position on the hardware stack
--    M (string)    -- a named memory location
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference
--   Cltd                       -- see instruction set reference
--   Set   (string, string)     -- sets a value from flags; the first operand is the
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
--
--   Dec   (opnd)               -- arithmetic correction: decrement  
--   Or1   (opnd)               -- arithmetic correction: or 0x0001                     
--   Sal1  (opnd)               -- arithmetic correction: shl 1           
--   Sar1  (opnd)               -- arithmetic correction: shr 1

-- Machine instruction printer
fun insnString (insn) {

  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl"
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    | x -> x
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)    -> regs [i]
    | S (i)    ->  if i >= 0
                   then sprintf ("-%d(%%ebp)", (i+1) * wordSize)
                   else sprintf ("%d(%%ebp)", 8 + (-1-i) * wordSize)
                   fi

    | M (x)    -> x
    | L (i)    -> sprintf ("$%d", i)
    | I (0, x) -> sprintf ("(%s)", opndString (x))
    | I (n, x) -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }

  case insn of
    Cltd               -> "\tcltd\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Lea   (s1, s2)     -> sprintf ("\tleal\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  | Dec   (s)          -> sprintf ("\tdecl\t%s\n", opndString (s))
  | Or1   (s)          -> sprintf ("\torl\t$0x0001,\t%s\n", opndString (s))
  | Sal1  (s)          -> sprintf ("\tsall\t%s\n", opndString (s))
  | Sar1  (s)          -> sprintf ("\tsarl\t%s\n", opndString (s))    
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks

fun makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements (globals).string)
  }

  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate () {
    case
      case stack of
        {}        -> [ebx, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (nLocals), nLocals + 1] fi
      | _         -> [S (0), 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- Takes n positions from the list, retursn a pair: the remaining list and the taken
  -- sublist
  fun take (list, n) {
    fun inner (n, acc, list) {
      if n == 0
      then [list, acc]
      else inner (n-1, list.hd : acc, list.tl)
      fi
    }

    inner (n, {}, list)
  }

  -- Pop n elements from symbolic state
  -- Return list of returned elements and new env
  fun pop (n) {
    -- Takes n positions from the list, retursn a pair: the remaining list and the taken
    -- sublist
    fun take (list, n) {
      fun inner (n, acc, list) {
        if n == 0
        then [list, acc]
        else inner (n-1, list.hd : acc, list.tl)
        fi
      }

      inner (n, {}, list)
    }

    case take (stack, n) of
      [new_stack, ret] ->  [reverse (ret), makeEnv (new_stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek () {
    stack.fst
  }

  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- References an allocation
  fun loc (alloc) {
    case alloc of
      Glb (x) -> M (globalName (x))
    | Arg (i) -> S (-1-i)
    | Loc (i) -> S (i)
    esac
  }

  -- Gets a list of global variables from the environment
  fun getGlobals () {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier () {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, true, stackMap, fLabel, nLocals)
  }

  -- Associates the current symbolic state with a label
  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, addMap (stackMap, l, stack), fLabel, nLocals)
  }

  -- Retrieves a stack for a label
  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    esac
  }

  -- Sets the label of current function
  fun enterFunction (fLabel, nL) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nL)
  }

  -- Gets the label of current function
  fun currentFunction () {
    fLabel
  }

  -- Gets the list of live registers past given symbolic stack depth
  fun liveRegisters (depth) {
    fun inner (d, acc, st) {
      case st of
        {}             -> acc
      | (r@R (_)) : tl -> inner (d+1, if d >= depth then r : acc else acc fi, tl)
      | _         : tl -> inner (d+1, acc, tl)
      esac
    }

    inner (0, {}, stack)
  }

  -- Registers a string literal and assigns it a name
  fun addString (s) {
    var escaped = makeString ((s.length + 1) * 2), i = 0, j = 0, name = sprintf ("string_%d", stringIndex);

    for skip, i < s.length, i := i+1 do
      case s[i] of
        '"'  -> escaped [j] :='"'; escaped [j+1] := '"'; j := j+2
      | '\n' -> escaped [j] :='\'; escaped [j+1] := 'n'; j := j+2
      | '\t' -> escaped [j] :='\'; escaped [j+1] := 't'; j := j+2
      | c    -> escaped [j] := c; j := j+1
      esac
    od;

    [makeEnv (stack, stackSlots, globals, addSet (strings, [name, substring (escaped, 0, j)]), stringIndex+1, false, stackMap, fLabel, nLocals),
     name]
  }

  -- Gets a list of all string literals and their names
  fun getStrings () {
    elements (strings)
  }

  -- Gets a local static size for the current function
  fun staticSize () {
    nLocals + stackSlots
  }

  [envString,
   allocate,
   push,
   0,
   pop,
   addGlobal,
   loc,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack,
   enterFunction,
   currentFunction,
   liveRegisters,
   addString,
   getStrings,
   staticSize]
}

-- Exported accessors
fun envString (env) {
  env [0] ()
}

fun allocate (env) {
  env [1] ()
}

fun push (env, x) {
  env [2] (x)
}

fun pop (env, n) {
  env [4] (n)
}

fun addGlobal (env, name) {
  env [5] (name)
}

fun loc (env, name) {
  env [6] (name)
}

fun getGlobals (env) {
  env [7] ()
}

fun getStackSize (env) {
  env [8] ()
}

fun peek (env) {
  env [9] ()
}

fun isBarrier (env) {
  env [10] ()
}

fun setBarrier (env) {
  env [11] ()
}

fun setStack (env, l) {
  env [12] (l)
}

fun retrieveStack (env, l) {
  env [13] (l)
}

fun enterFunction (env, fLabel, nA) {
  env [14] (fLabel, nA)
}

fun currentFunction (env) {
  env [15] ()
}

fun liveRegisters (env, depth) {
  env [16] (depth)
}

fun addString (env, s) {
  env [17] (s)
}

fun getStrings (env) {
  env [18] ()
}

fun staticSize (env) {
  env [19] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), emptySet (compare), 0, false, emptyMap (compare), "", 0)
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates integer definition
fun intDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates string definition
fun stringDef ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

-- Generates function prologue
fun prologue (fLabel) {
  singletonBuffer (Push  (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", M (sprintf ("$%s_SIZE", fLabel)), esp)
}

-- Generates function epilogue
fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * wordSize));

  if compare (env.currentFunction, "main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("^", eax, eax) <+ Ret <+ metaDef]
  else case pop (env, 1) of
         [{y}, env] -> [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Mov (y, eax) <+ Ret <+ metaDef]
       esac
  fi
}

-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | I (_, _) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else
    if compare (from, to) == 0
    then emptyBuffer ()
    else singletonBuffer (Mov (from, to))
    fi
  fi
}

-- Return [code buffer, output dest]
-- Uses eax and edx as immediate regiters
-- s2 should be register
fun opImpl(lop, s1, s2) {

  fun cmpWrapper(lop, s1, s2) {
    [singletonBuffer (Binop ("cmp", s1, s2)) <+ Set (lop, "%al") <+ Binop ("&&", L (1), eax), eax]
  }

  var divCode = move (s2, eax) <+ Cltd <+ IDiv (s1);

  fun toBit(s) {
    move (s, edx) <+ Binop ("testl", edx, edx) <+ Set ("nz", "%dl") <+ Binop ("&&", L (1), edx) <+> move (edx, s)
  }

  case lop of
    "&&" -> [toBit (s1) <+> toBit (s2) <+ Binop ("&&", s1, s2), s2]
    | "!!" -> [toBit (s1) <+> toBit (s2) <+ Binop ("!!", s1, s2), s2]
    | "/" -> [divCode, eax]
    | "%" -> [divCode, edx]
    | "<" -> cmpWrapper("l", s1, s2)
    | "<=" -> cmpWrapper("le", s1, s2)
    | ">" -> cmpWrapper("g", s1, s2)
    | ">=" -> cmpWrapper("ge", s1, s2)
    | "==" -> cmpWrapper("e", s1, s2)
    | "!=" -> cmpWrapper("ne", s1, s2)
    -- TODO: replace to + - *
    | _ -> [singletonBuffer (Binop (lop, s1, s2)), s2]
  esac
}

-- Boxes an immediate value
fun makeBox (n) {
  n * 2 + 1
}

-- Generates a fixednum representation
-- conversion
fun toFixedNum (r) {
  singletonBuffer (Sal1 (r)) <+ Or1 (r)
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {

  -- Compiles call with save/restore GP registers
  -- Return [new_env, code]
  fun saveCallRestore (env, code, fLabel, nargs, extra_args_pref, extra_args_suff) {
      fun pushAll (list) {
         listBuffer (map (fun (reg) { Push (reg) }, list))
      }
      var i;
      var live = liveRegisters (env, nargs);
      code := code <+> pushAll (live);
      code := code <+> pushAll (extra_args_pref);
      -- Move arguments from symbolic stack into hardware
      for i := 0, i < nargs, i := i + 1 do
        case pop (env, 1) of
          [{x}, new_env] -> (
            code := code <+ Push (x);
            env := new_env
          )
        esac
      od;
      code := code <+> pushAll (extra_args_suff);
      -- Call & restore live
      case allocate (env) of
        [s, env] ->
          [env, code
            <+ Call (fLabel)
            <+ Mov (eax, s)
            <+ Binop ("+", L (wordSize * (nargs + size (extra_args_pref) + size (extra_args_suff))), esp)
            <+> listBuffer ( map (fun (reg) { Pop (reg) }, reverse (live)) )
          ]
      esac
  }

  foldl (
    fun ([env, scode], i) {
      var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");
      -- fprintf(stderr, "%s\n", showSMInsn (i));
      case i of
        LD (x) ->
        case allocate (env) of
          [s, env] -> [env, code <+> move (env.loc (x), s)]
        esac
      | LDA (x) ->
        case allocate (env) of
          [s, env] -> [env, code <+ Lea (env.loc (x), eax) <+> move (eax, s)]
        esac
      | ST (x) -> [env, code <+> move (env.peek, env.loc (x))]
      | STI ->
        case pop (env, 2) of
          [{v, rx}, env] ->
            case allocate (env) of
              [s, env] -> [env, code <+> move (v, if memOpnd (rx) then rx else I (0, rx) fi) <+> move (v, s)]
            esac
        esac
      | STA ->
        case pop (env, 3) of
          [{v, i, a}, env] -> saveCallRestore (env, code, "Bsta", 0, {}, {v, i, a})
        esac
      | ELEM ->
        case pop (env, 2) of
          [{i, a}, env] -> saveCallRestore (env, code, "Belem", 0, {}, {i, a})
        esac
      | ARRAY (n) -> saveCallRestore (env, code, "Barray", n, {}, {L (n)})
      | STRING (s) ->
        case addString (env, s) of
          [env, sname] -> saveCallRestore (env, code, "Bstring", 0, {}, {M ("$" ++ sname)})
        esac
      -- tagHash defined in standard library
      | SEXP (stag, n) -> saveCallRestore (env, code, "Bsexp", n, {L (tagHash (stag))}, {L (n + 1)})
      | CONST (n) ->
        case allocate (env) of
          [s, env] -> [env, code <+> move (L (n), s)]
        esac
      | BINOP (lop) ->
        case pop (env, 2) of
          [{s2, s1}, env] ->
            case allocate (env) of
              [sdest, env] ->
                var movS2 = if s2.memOpnd then move (s2, eax) else emptyBuffer () fi;
                case opImpl (lop, s1, if s2.memOpnd then eax else s2 fi) of
                  [opCode, opRes] -> [env, code <+> movS2 <+> opCode <+> move (opRes, sdest)]
                esac
            esac
        esac
      | LABEL (label) -> [if env.isBarrier then env.retrieveStack (label) else env fi, code <+ Label (label)]
      | JMP (label) -> [setBarrier (setStack (env, label)), code <+ Jmp (label)]
      | CJMP (t, label) ->
        case pop (env, 1) of
          [{x}, env] -> [setBarrier (setStack (env, label)), code <+ Binop ("cmp", L (0), x) <+ CJmp (t, label)]
        esac
      | DROP ->
        case pop (env, 1) of
          [_, env] -> [env, code]
        esac
      | GLOBAL (x) -> [addGlobal (env, x), code]
      | BEGIN (fLabel, nargs, nlocs) -> [enterFunction (env, fLabel, nlocs), code <+ Label (fLabel) <+> prologue (fLabel) ]
      | END ->
        case epilogue (env) of
          [env, ecode] -> [env, code <+> ecode]
        esac
      | CALL (fLabel, nargs) -> saveCallRestore (env, code, fLabel, nargs, {}, {})
      | BUILTIN (fName, nargs) -> saveCallRestore (env, code, "L" ++ fName, nargs, {}, {})
      esac
    }, [env, emptyBuffer ()], code)
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code] ->
       var asmFile = args.getBaseName ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val -> "../runtime/"
                     | path -> path
                     esac ++ "/runtime.o";

       fwrite (asmFile,
               map (insnString,
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer (map (intDef   , getGlobals (env))) <+>
                                   listBuffer (map (stringDef, getStrings (env)))) <+>
                      codeSection (code)
                    ).stringcat);

       system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
