import X86CompilerEnv;
import X86CompilerUtils;
import X86CompilerBinop;
import SMPrinter;
import Buffer;
import List;

-- We need to distinguish the following operand types: 
--    R (int)       -- hard register
--    S (int)       -- a position on the hardware stack
--    M (string)    -- a named memory location
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)

fun checkBarrier (env, label) {
  if env.isBarrier
  then env.retrieveStack (label)
  else env
  fi
}

fun compileIns([env, scode], i) {
  var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");
  case i of
    READ ->
    case env.allocate of [s, env] ->
      [env, code <+ Call ("Lread") <+ Mov (eax, s)]
    esac
  | WRITE ->
    case env.pop of [s, env] -> 
      [env, code <+ Push (s) <+ Call ("Lwrite") <+ Pop (eax)]
    esac
  | LD (x) ->
    case env.allocate of [s, env] ->
      [env.addGlobal (x), code <+> move (env.locate (x), s)]
    esac
  | LDA (x) ->
    case env.allocate of [s, env] ->
      [env.addGlobal (x), code <+> lea (env.locate (x), s)]
    esac
  | ST (x) ->
    case env.peek of s -> 
      [env.addGlobal (x), code <+> move (s, env.locate (x))]
    esac
  | STI ->
    case env.pop of [value, env] ->
      case env.peek of addr ->
        [env, code <+> move (value, I (0, addr)) <+> move (value, addr)]
      esac
    esac
  | CONST (n) ->
    case env.allocate of [s, env] -> 
      [env, code <+ Mov (L (n), s)]
    esac
  | BINOP (s) -> compileBinop (s, env, code)
  | LABEL (l) -> [env.checkBarrier (l), code <+ Label (l)]
  | JMP (l) -> [env.setBarrier (env.setStack (l)), code <+ Jmp (l)]
  | CJMP (c, l) ->
    case env.pop of [s, env] ->
      [env.setStack (l), code <+ Binop ("cmp", L (0), s) <+ CJmp (c, l)]
    esac
  | DUP ->
    case env.peek of value ->
      case env.allocate of [top, env] ->
        [env, code <+> move (value, top)]
      esac
    esac
  | DROP ->
    case env.pop of [_, env] ->
      [env, code]
    esac
  esac
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
public fun compile (env, code) {
  foldl (compileIns, [env, emptyBuffer ()], code)
}
