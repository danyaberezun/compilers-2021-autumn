import X86CompilerUtils;
import X86CompilerEnv;
import List;
import Buffer;

fun compileSrcDst (op, src, dst) {
  if stackOpnd (dst)
  then  {
          Mov (dst, eax),
          Binop (op, src, eax),
          Mov (eax, dst)
        }
  else  {
          Binop (op, src, dst)
        }
  fi
}

fun compileDivRem (op, src, dst) {
  {
    Mov (dst, eax),
    Cltd,
    IDiv (src),
    case op of
      "/" -> Mov (eax, dst)
    | "%" -> Mov (edx, dst)
    esac
  }
}

fun compileLogical (op, src, dst) {
  if stackOpnd (dst)
  then  {
          Mov (dst, eax),
          Binop ("cmp", src, eax),
          Mov (L (0), eax),
          Set (suffix (op), "%al"),
          Mov (eax, dst)
        }
  else  {
          Binop ("cmp", src, dst),
          Mov (L (0), eax),
          Set (suffix (op), "%al"),
          Mov (eax, dst)
        }
  fi
}

public fun compileBinop (op, env, code) {
  case env.pop of [src, env] -> case env.peek of dst ->
    [env, foldl (infix <+, code,
      case op of
        "+"  -> compileSrcDst ("+", src, dst)
      | "-"  -> compileSrcDst ("-", src, dst)
      | "*"  -> compileSrcDst ("*", src, dst)
      | "&&" -> convertToBool (src) +++ convertToBool (dst) +++ compileSrcDst ("&&", src, dst)
      | "!!" -> convertToBool (src) +++ convertToBool (dst) +++ compileSrcDst ("!!", src, dst)
      | "/"  -> compileDivRem ("/", src, dst)
      | "%"  -> compileDivRem ("%", src, dst)
      | "==" -> compileLogical ("==", src, dst)
      | "!=" -> compileLogical ("!=", src, dst)
      | "<"  -> compileLogical ("<", src, dst)
      | "<=" -> compileLogical ("<=", src, dst)
      | ">"  -> compileLogical (">", src, dst)
      | ">=" -> compileLogical (">=", src, dst)
      esac
    )]
  esac esac
}
