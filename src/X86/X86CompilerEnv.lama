import Collection;

-- Assembler language interface
-- The registers: 
public regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
public nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers: 
public ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We need to know the word size to calculate offsets correctly
public wordSize = 4;                                                               


-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks
public fun makeEnv (stack, stackSlots, globals, barrier, stackMap) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements (globals).string)
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate () {
    case 
      case stack of
        {}        -> [ebx, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (0), 1] fi
      | _         -> [S (0), 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, barrier, stackMap)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, barrier, stackMap)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, barrier, stackMap)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals, barrier, stackMap)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek () {
    stack.fst
  }

  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), barrier, stackMap)
  }

  -- References a global variable
  fun locate (name) {
    M (globalName (name))
  }
  
  -- Gets a list of global variables from the environment
  fun getGlobals () {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier () {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, true, stackMap)
  }

  -- Associates the current symbolic state with a label
  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, false, addMap (stackMap, l, stack))
  }

  -- Retrieves a stack for a label
  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, false, stackMap)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, false, stackMap)
    esac
  }

  [envString,
   allocate,
   push,
   pop,
   pop2,
   addGlobal,
   locate,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack]
}

-- Exported accessors
public fun envString (env) {
  env [0] ()
}

public fun allocate (env) {
  env [1] ()
}

public fun push (env, x) {
  env [2] (x)
}

public fun pop (env) {
  env [3] ()
}

public fun pop2 (env) {
  env [4] ()
}

public fun addGlobal (env, name) {
  env [5] (name)
}

public fun locate (env, name) {
  env [6] (name)
}

public fun getGlobals (env) {
  env [7] ()
}

public fun getStackSize (env) {
  env [8] ()
}

public fun peek (env) {
  env [9] ()
}

public fun isBarrier (env) {
  env [10] ()
}

public fun setBarrier (env) {
  env [11] ()
}

public fun setStack (env, l) {
  env [12] (l)
}

public fun retrieveStack (env, l) {
  env [13] (l)
}

-- Creates an initial environment
public fun initEnv () {
  makeEnv (0, emptySet (compare), emptySet (compare), false, emptyMap (compare))
}
