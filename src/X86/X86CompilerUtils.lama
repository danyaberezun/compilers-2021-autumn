import Buffer;
import X86CompilerEnv;

-- Checks if an operand resides on a stack
public fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
public fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
public fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

public fun lea (from, to) {
  if memOpnd (to)
  then singletonBuffer (Lea (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Lea (from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
public fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

public fun convertToBool (loc) {
  {
    Binop ("cmp", L (0), loc),
    Mov (L (0), eax),
    Set (suffix ("!="), "%al"),
    Mov (eax, loc)
  }
}

-- Codegeneration helper functions
-- Generates code section
public fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
public fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates data definition
public fun dataDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
public fun prologue (fLabel) {
  singletonBuffer (Push  (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", M (sprintf ("$%s_SIZE", fLabel)), esp)  
}

-- Generates function epilogue
public fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunction, env.staticSize * wordSize));

  if compare (env.currentFunction, "main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("^", eax, eax) <+ Ret <+ metaDef]
  else case env.pop of
         [y, env] -> [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Mov (y, eax) <+ Ret <+ metaDef]
       esac
  fi
}
