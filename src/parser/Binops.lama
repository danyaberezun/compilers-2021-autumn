import Context;
import List;
import Lexer;
import STM;
import Fun;

fun procBinops (binops) {
  fun makeBinop (l, [loc, op], r) {
    fun (context) {
      case op of
        ":=" -> 
        l (Ref) =>> fun (l) {
        r (Val) =>  fun (r) {
        Assn (l, r)
        }}
      | _    -> 
        l (Val) =>> fun (l) {
        r (Val) =>  fun (r) {
        Binop (op, l, r)
        }}
      esac => fun (parsed) {
      fitVal (context, parsed, loc)
    }}
  }

  fun procBinop (op) {
    [syntax (pos s[op]), makeBinop]
  }

  fun procBinopGroup ([assoc, ops]) {
    [assoc, map (procBinop, ops)]
  }

  map (procBinopGroup, binops)
}

public binops = procBinops ({
  [Right, {":="}],
  [Left,  {"!!"}],
  [Left,  {"&&"}],
  [Nona,  {"==", "!=", "<", "<=", ">", ">="}],
  [Left,  {"+", "-"}],
  [Left,  {"*", "/", "%"}]
});
