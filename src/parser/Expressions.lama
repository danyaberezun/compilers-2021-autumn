import Lexer;
import ParserUtils;
import Binops;
import Context;
import Ostap;
import Fun;
import List;

-- Decimal expression
var eDecimal = memo $ eta syntax (
  loc=pos x=decimal 
  {fun (a) {
      fitVal (a, Const (stringInt (x)), loc)
  }}
);

-- Identifier expression
var eIdentifier = memo $ eta syntax (
  loc=pos x=lident 
  {fun (a) {
      fitRef (a, x, loc)
  }}
);

-- Read expression
var eRead = memo $ eta syntax(
  loc=pos kRead eIdent=parens[exp]
  {fun (a) {
    fitVoid (a, Read (eIdent (Ref)), loc)
  }}
);

-- Write expression
var eWrite = memo $ eta syntax(
  loc=pos kWrite eVal=parens[exp]
  {fun (a) {
    fitVoid (a, Write (eVal (Val)), loc)
  }}
);

-- Skip expression
var eSkip = memo $ eta syntax(
  loc=pos kSkip
  {fun (a) {
    fitVoid (a, Skip, loc)
  }}
);

-- If expression
fun halfIf (expr, thenStmt) {
  fun (elseStmt) {
    If (expr, thenStmt, elseStmt)
  }
}
fun accum (a) {
  fun (stmt, halfIf) {
    halfIf (a) (stmt)
  }
}
var ifP = memo $ eta syntax (
  kIf e=exp kThen eThen=exp
  {fun (a) { 
    halfIf (e (Val), eThen (a)) 
  }}
);
var elifP = memo $ eta syntax (
  kElif e=exp kThen eThen=exp
  {fun (a) {
    halfIf (e (Val), eThen (a)) 
  }}
);
var elseP = memo $ eta syntax (
  loc=pos s=(-kElse exp)? 
  {fun (a) {
    case s of
      Some (s) -> s (a)
    | None     -> fitVoid (a, Skip, loc)
    esac
  }}
);
var eIf = memo $ eta syntax (
  sThen=ifP sElif=elifP* sElse=elseP kFi 
  {fun (a) {
    foldr (accum (a), sElse (a), sThen:sElif)
  }}
);

-- While expression
var eWhile = memo $ eta syntax (
  loc=pos kWhile eCond=exp kDo eBody=exp kOd 
  {fun (a) {
    fitVoid (a, While (eCond (Val), eBody (Void)), loc)
  }}
);

-- For expression
var eFor = memo $ eta syntax (
  loc=pos kFor eInit=exp comma eCond=exp comma eCounter=exp kDo eBody=exp kOd
  {fun (a) {
    var expr = Seq (eInit (Void), 
                    While (eCond (Val), 
                           Seq (eBody (Void), 
                                eCounter (Void))));
    fitVoid (a, expr, loc)
  }}
);

-- Do-While expression
var eDoWhile = memo $ eta syntax (
  loc=pos kDo eBody=exp kWhile eCond=exp kOd 
  {fun (a) {
    DoWhile (eBody (Void), eCond (Val)) 
  }}
);

var primary = memo $ eta syntax (
  parens[exp]
| eDecimal
| eIdentifier
| eIf
| eWhile
| eFor
| eDoWhile
| eRead
| eWrite
| eSkip
);

var basic = memo $ eta (expr (binops, primary));

public exp = memo $ eta syntax (
  basic 
| s1=basic semicolon s2=exp 
  {fun (a) {
      Seq (s1 (Void), s2 (a))
  }}
);
