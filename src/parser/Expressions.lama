import Lexer;
import ParserUtils;
import Binops;
import Context;
import Ostap;
import Fun;
import List;
import Utils;
import STM;

-- Local utilities
var expVal = memo $ eta syntax ( 
  e=exp { e (Val) }
);

-- Decimal expression
var eDecimal = memo $ eta syntax (
  loc=pos x=decimal 
  {fun (a) {
      returnST $ fitVal (a, Const (stringInt (x)), loc)
  }}
);

-- Identifier expression
var eIdentifier = memo $ eta syntax (
  loc=pos x=lident
  {fun (a) {
      returnST $ fitRef (a, x, loc)
  }}
);

-- Skip expression
var eSkip = memo $ eta syntax(
  loc=pos kSkip
  {fun (a) {
    returnST $ fitVoid (a, Skip, loc)
  }}
);

-- If expression
fun halfIf (expr, thenStmt) {
  fun (elseStmt) {
    If (expr, thenStmt, elseStmt)
  }
}
fun accum (a) {
  fun (stmt, halfIf) {
    stmt =>> fun (stmt) {
    halfIf (a) => fun (halfIf) {
    halfIf (stmt)
  }}}
}
var ifP = memo $ eta syntax (
  kIf e=exp kThen eThen=scopeExpr
  {fun (a) {
    e (Val) =>> fun (e) {
    eThen (a) => fun (eThen) { 
    halfIf (e, eThen)
  }}}}
);
var elifP = memo $ eta syntax (
  kElif e=exp kThen eThen=scopeExpr
  {fun (a) {
    e (Val) =>> fun (e) {
    eThen (a) => fun (eThen) { 
    halfIf (e, eThen)
  }}}}
);
var elseP = memo $ eta syntax (
  loc=pos s=(-kElse scopeExpr)?
  {fun (a) {
    case s of
      Some (s) -> s (a)
    | None     -> returnST $ fitVoid (a, Skip, loc)
    esac
  }}
);
var eIf = memo $ eta syntax (
  sThen=ifP sElif=elifP* sElse=elseP kFi
  {fun (a) {
    foldr (accum (a), sElse (a), sThen:sElif)
  }}
);

-- While expression
var eWhile = memo $ eta syntax (
  loc=pos kWhile eCond=exp kDo eBody=scopeExpr kOd 
  {fun (a) {
    eCond (Val) =>> fun (eCond) {
    eBody (Void) => fun (eBody) {
    fitVoid (a, While (eCond, eBody), loc)
  }}}}
);

-- For expression
var eFor = memo $ eta syntax (
  loc=pos kFor eInit=scopeExpr comma eCond=exp comma eCounter=exp kDo eBody=scopeExpr kOd
  {fun (a) {
    eInit (Void) =>> fun (eInit) {
    eCond (Val) =>> fun (eCond) {
    eCounter (Void) =>> fun (eCounter) {
    eBody (Void) => fun (eBody) {
    var expr = distributeScope (eInit, fun (init) {
      Seq (init, While (eCond, Seq (eBody, eCounter)))  
    });
    fitVoid (a, expr, loc)
  }}}}}}
);

-- Do-While expression
var eDoWhile = memo $ eta syntax (
  loc=pos kDo eBody=scopeExpr kWhile eCond=exp kOd 
  {fun (a) {
    eBody (Void) =>> fun (eBody) {
    eCond (Val) => fun (eCond) {
    distributeScope (eBody, fun (eBody) {
      fitVoid (a, DoWhile (eBody, eCond), loc)
    })
  }}}}
);

-- Function call expression
var eFunCall = memo $ eta syntax (
  loc=pos x=lident args=parens[list0 (expVal)]
  {fun (a) {
    chainST (args) => fun (args) {
    fitVal (a, Call (x, args), loc)
  }}}
);

-- Array literal
var elArray = memo $ eta syntax (
  loc=pos args=brackets[list0(expVal)]
  {fun (a) {
    chainST (args) => fun (args) {
    fitVal (a, Array (args), loc)
  }}}
);

-- String literal
var elString = memo $ eta syntax (
  loc=pos strv=strlit
  {fun (a) {
    returnST $ fitVal (a, String (strv), loc)
  }}
);

-- Character literal
var elChar = memo $ eta syntax (
  loc=pos chr=chrlit
  {fun (a) {
     returnST $ fitVal (a, Const (chr), loc)
  }}
);

-- S-expression
var eSexpr = memo $ eta syntax (
  loc=pos name=uident args=parens[list0(expVal)]?
  {fun (a) {
    args := case args of None -> {} | Some (args) -> args esac;
    chainST (args) => fun (args) {
    fitVal (a, Sexp (name, args), loc)
  }}}
);

-- Case expression
var caseBranch = memo $ eta syntax (
  loc=pos p=pattern arrow e=scopeExpr
  {fun (a) {
    p =>> fun (p) {
    e (a) => fun (e) {
    [p, e]
  }}}}
);
var eCase = memo $ eta syntax (
  loc=pos kCase sc=exp kOf b=caseBranch bs=(-vline caseBranch)* kEsac
  {fun (a) {
    bs := map (fun (b) { b (a) }, b:bs);
    sc (Val) =>> fun (sc) {
    chainST (bs) =>> fun (bs) {
    freshName => fun (name) {
    Scope (
      { Var ({ name }) },
      Seq ( 
        Ignore (Assn (Ref (name), sc)),
        Case (name, reifyPatternBindings (name, bs))
      )
    )
  }}}}}
);

-- Patterns
var pWildcard = memo $ eta syntax (
  botline
  { returnST $ Wildcard }
);
var pArray = memo $ eta syntax (
  args=brackets[list0(pattern)]
  {
    chainST (args) => fun (args) {
    PArray (args)
  }}
);
var pSexpr = memo $ eta syntax (
  name=uident args=parens[list0(pattern)]?
  {
    args := case args of None -> {} | Some (args) -> args esac;
    chainST (args) => fun (args) {
    PSexp (name, args)
  }}
);
var pNamed = memo $ eta syntax (
  name=lident pat=(-dog pattern)?
  {
    pat := case pat of None -> returnST $ Wildcard | Some (pat) -> pat esac;
    pat => fun (pat) {
    PNamed (name, pat)
  }}
);
var pDecimal = memo $ eta syntax (
  x=decimal
  { returnST $ PConst (stringInt (x)) }
);

var pattern = memo $ eta syntax (
  pWildcard
| pArray
| pSexpr
| pNamed
| pDecimal
);

var primary = memo $ eta syntax (
  parens[scopeExpr]
| eDecimal
| elArray
| elString
| elChar
| eIdentifier
| eCase
| eSexpr
| eFunCall
| eIf
| eWhile
| eFor
| eDoWhile
| eSkip
);

var postfix = memo $ eta syntax (
    loc=pos e=primary ps=(i=inbr[s("["), exp, s("]")] {Index (i (Val))})* {
      fun (a) {
        foldl (fun (e, p) {                                                                            
                 case p of                                                                                   
                   Index (i) ->
                    fun (a) {
                      case a of
                        Ref -> e (Val) =>> fun (e) {
                               i       =>  fun (i) {
                                 ElemRef (e, i)
                               }} 
                      | _   -> fitVal (a, e (Val) =>> fun (e) {
                                               i       =>  fun (i) {
                                               Elem (e, i)
                                               }},
                                            loc)
                      esac
                    }
                 esac                                                                            
               }, e, ps) (a)
      }}
  );

var basic = memo $ eta (expr (binops, postfix));

var exp = memo $ eta syntax (
  basic 
| s1=basic semicolon s2=exp 
  {fun (a) {
    s1 (Void) =>> fun (s1) {
    s2 (a)    =>  fun (s2) {
    Seq (s1, s2)
  }}}}
);

var definition = memo $ eta syntax (
    kVar ds=list[syntax (x=lident e=(-s["="] basic)? {case e of
                                                        None -> returnST $ [x, None]
                                                      | Some (e) ->
                                                          e (Val) => fun (e) {[x, Some (e)]}
                                                      esac})] s[";"] {
      chainST (ds) => fun (ds) {Var (ds)}
    } |
    kVal ds=list[syntax (x=lident s["="] e=basic {e (Val) => fun (e) {[x, e]}})] s[";"] {
      chainST (ds) => fun (ds) {Val (ds)}
    } |  
    kFun name=lident args=inbr[s("("), list0 (lident), s(")")] body=inbr[s("{"), scopeExpr, s("}")] {
      body (Weak) => fun (body) {Fun (name, args, body)}
    }
  );

public scopeExpr = memo $ eta syntax (
  loc=pos ds=definition* e=exp? 
  {fun (a) {
    fun (e) {
        case ds of
          {} -> e
        | _  -> chainST (ds) =>> fun (ds) {
                e            =>  fun (e)  {
                  expandScope (ds, e)
                }}
        esac
      }
      (case e of 
        Some (e) -> e (a)
      | _        -> returnST $ Skip
      esac)
    }
  }
);
