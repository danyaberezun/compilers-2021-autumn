import Lexer;
import ParserUtils;
import Binops;
import Context;
import Ostap;
import Fun;
import List;
import Utils;

-- Decimal expression
var eDecimal = memo $ eta syntax (
  loc=pos x=decimal 
  {fun (a) {
      fitVal (a, Const (stringInt (x)), loc)
  }}
);

-- Identifier expression
var eIdentifier = memo $ eta syntax (
  loc=pos x=lident
  {fun (a) {
      fitRef (a, x, loc)
  }}
);

-- Read expression
var eRead = memo $ eta syntax(
  loc=pos kRead eIdent=parens[exp]
  {fun (a) {
    fitVoid (a, Read (eIdent (Ref)), loc)
  }}
);

-- Write expression
var eWrite = memo $ eta syntax(
  loc=pos kWrite eVal=parens[exp]
  {fun (a) {
    fitVoid (a, Write (eVal (Val)), loc)
  }}
);

-- Skip expression
var eSkip = memo $ eta syntax(
  loc=pos kSkip
  {fun (a) {
    fitVoid (a, Skip, loc)
  }}
);

-- If expression
fun halfIf (expr, thenStmt) {
  fun (elseStmt) {
    If (expr, thenStmt, elseStmt)
  }
}
fun accum (a) {
  fun (stmt, halfIf) {
    halfIf (a) (stmt)
  }
}
var ifP = memo $ eta syntax (
  kIf e=exp kThen eThen=scopeExpr
  {fun (a) { 
    halfIf (e (Val), eThen (a)) 
  }}
);
var elifP = memo $ eta syntax (
  kElif e=exp kThen eThen=scopeExpr
  {fun (a) {
    halfIf (e (Val), eThen (a)) 
  }}
);
var elseP = memo $ eta syntax (
  loc=pos s=(-kElse scopeExpr)? 
  {fun (a) {
    case s of
      Some (s) -> s (a)
    | None     -> fitVoid (a, Skip, loc)
    esac
  }}
);
var eIf = memo $ eta syntax (
  sThen=ifP sElif=elifP* sElse=elseP kFi 
  {fun (a) {
    foldr (accum (a), sElse (a), sThen:sElif)
  }}
);

-- While expression
var eWhile = memo $ eta syntax (
  loc=pos kWhile eCond=exp kDo eBody=scopeExpr kOd 
  {fun (a) {
    fitVoid (a, While (eCond (Val), eBody (Void)), loc)
  }}
);

-- For expression
var eFor = memo $ eta syntax (
  loc=pos kFor eInit=scopeExpr comma eCond=exp comma eCounter=exp kDo eBody=scopeExpr kOd
  {fun (a) {
    var expr = distributeScope (eInit (Void), fun (init) {
      Seq (init, 
        While (eCond (Val), 
          Seq (eBody (Void), 
            eCounter (Void))))
    });
    fitVoid (a, expr, loc)
  }}
);

-- Do-While expression
var eDoWhile = memo $ eta syntax (
  loc=pos kDo eBody=scopeExpr kWhile eCond=exp kOd 
  {fun (a) {
    distributeScope (eBody (Void), fun (eBody) {
      fitVoid (a, DoWhile (eBody, eCond (Val)), loc)
    })
  }}
);

-- Function call expression
var eFunCall = memo $ eta syntax (
  loc=pos x=lident args=parens[list0 (exp)]
  {fun (a) {
    fitVal (a, Call (x, map (fun (arg) { arg (Val) }, args)), loc)
  }}
);

-- Function definition
var dFun = memo $ eta syntax (
  kFun name=lident args=parens[list0 (lident)] body=braces[scopeExpr]
  { Fun (name, args, body (Weak)) }
);

-- Variable definition
var initializerVar = memo $ eta syntax (
  eq e=basic 
  { e (Val) }
);
var singleVar = memo $ eta syntax (
  lident initializerVar?
);
var dVar = memo $ eta syntax (
  kVar ds=list[singleVar] semicolon
  { Var (ds) }
);

var primary = memo $ eta syntax (
  parens[scopeExpr]
--| braces[scopeExpr]
| eDecimal
| eIdentifier
| eFunCall
| eIf
| eWhile
| eFor
| eDoWhile
| eRead
| eWrite
| eSkip
);

var basic = memo $ eta (expr (binops, primary));

var exp = memo $ eta syntax (
  basic 
| s1=basic semicolon s2=exp 
  {fun (a) {
    Seq (s1 (Void), s2 (a))
  }}
);

var definition = memo $ eta syntax (
  dFun
| dVar
);

public scopeExpr = memo $ eta syntax (
  loc=pos ds=definition* e=exp? 
  {fun (a) {
    e := case e of 
      Some (e) -> e (a)
    | _        -> fitVoid (a, Skip, loc)
    esac;
    case ds of
      {} -> e
    | _  -> expandScope (ds, e) 
    esac
  }}
);
