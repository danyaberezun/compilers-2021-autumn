import SMInterpreterEnv;
import SMUtils;
import State;
import World;
import InterpretUtils;

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, [vstack, state, world], insns) {
  fun ev (vstack, state, world, insns) {
    case insns of
      ins:insns ->
        case ins of
          READ         -> case readWorld (world) of [value, newWorld] -> ev (value : vstack, state, newWorld, insns) esac
        | WRITE        -> case vstack of head:tail -> ev (tail, state, writeWorld (head, world), insns) esac
        | BINOP (s)    -> case vstack of r:l:tail -> ev (opValue (s) (l, r) : tail, state, world, insns) esac
        | LD    (x)    -> ev (state (x) : vstack, state, world, insns)
        | LDA   (x)    -> ev (x : vstack, state, world, insns)
        | ST    (x)    -> case vstack of v:_ -> ev (vstack, state <- [x, v], world, insns) esac
        | STI          -> case vstack of v:x:tail -> ev (v:tail, state <- [x, v], world, insns) esac
        | CONST (n)    -> ev (n : vstack, state, world, insns)
        | LABEL (s)    -> ev (vstack, state, world, insns)
        | JMP   (l)    -> ev (vstack, state, world, env.fromLabel (l))
        | CJMP  (c, l) ->
          case vstack of head:tail ->
            if jmpCond (c) (head)
            then ev (tail, state, world, env.fromLabel (l))
            else ev (tail, state, world, insns)
            fi
          esac
        | DUP          -> case vstack of head:_ -> ev (head:vstack, state, world, insns) esac
        | DROP         -> case vstack of _:tail -> ev (tail, state, world, insns) esac
        esac
    | {} -> [vstack, state, world]
    esac
  }

  ev (vstack, state, world, insns)
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM_ (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}
